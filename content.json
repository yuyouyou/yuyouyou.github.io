[{"title":"JavaScript风格指南","date":"2017-03-17T02:25:09.000Z","path":"2017/03/17/tenth-article/","text":"作者根据Robert C. Martin《代码整洁之道》总结了适用于JavaScript的软件工程原则《Clean Code JavaScript》。本文是对其的翻译。不必严格遵守本文的所有原则，有时少遵守一些效果可能会更好，具体应根据实际情况决定。这是根据《代码整洁之道》作者多年经验整理的代码优化建议，但也仅仅只是一份建议。软件工程已经发展了50多年，至今仍在不断前进。现在，把这些原则当作试金石，尝试将他们作为团队代码质量考核的标准之一吧。最后你需要知道的是，这些东西不会让你立刻变成一个优秀的工程师，长期奉行他们也并不意味着你能够高枕无忧不再犯错。千里之行，始于足下。我们需要时常和同行们进行代码评审，不断优化自己的代码。不要惧怕改善代码质量所需付出的努力，加油。 目录 变量 函数 对象和数据结构 类 测试 并发 错误处理 格式化 注释 变量使用有意义，可读性好的变量名反例:1var yyyymmdstr = moment().format('YYYY/MM/DD'); 正例:1var yearMonthDay = moment().format('YYYY/MM/DD'); 回到目录 使用ES6的const定义常量反例中使用”var”定义的”常量”是可变的。 在声明一个常量时，该常量在整个程序中都应该是不可变的。 反例:1var FIRST_US_PRESIDENT = \"George Washington\"; 正例:1const FIRST_US_PRESIDENT = \"George Washington\"; 回到目录 对功能类似的变量名采用统一的命名风格反例:123getUserInfo();getClientData();getCustomerRecord(); 正例:1getUser(); 回到目录 使用易于检索名称我们需要阅读的代码远比自己写的要多，使代码拥有良好的可读性且易于检索非常重要。阅读变量名晦涩难懂的代码对读者来说是一种相当糟糕的体验。让你的变量名易于检索。 反例:1234// 525600 是什么?for (var i = 0; i &lt; 525600; i++) &#123; runCronJob();&#125; 正例:12345// Declare them as capitalized `var` globals.var MINUTES_IN_A_YEAR = 525600;for (var i = 0; i &lt; MINUTES_IN_A_YEAR; i++) &#123; runCronJob();&#125; 回到目录 使用说明变量(即有意义的变量名)反例:12const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d&#123;5&#125;)?$/;saveCityState(cityStateRegex.match(cityStateRegex)[1], cityStateRegex.match(cityStateRegex)[2]); 正例:12345const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d&#123;5&#125;)?$/;const match = cityStateRegex.match(cityStateRegex)const city = match[1];const state = match[2];saveCityState(city, state); 回到目录 不要绕太多的弯子显式优于隐式。 反例:12345678910var locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((l) =&gt; &#123; doStuff(); doSomeOtherStuff(); ... ... ... // l是什么？ dispatch(l);&#125;); 正例:123456789var locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((location) =&gt; &#123; doStuff(); doSomeOtherStuff(); ... ... ... dispatch(location);&#125;); 回到目录 避免重复的描述当类/对象名已经有意义时，对其变量进行命名不需要再次重复。 反例:123456789var Car = &#123; carMake: 'Honda', carModel: 'Accord', carColor: 'Blue'&#125;;function paintCar(car) &#123; car.carColor = 'Red';&#125; 正例:123456789var Car = &#123; make: 'Honda', model: 'Accord', color: 'Blue'&#125;;function paintCar(car) &#123; car.color = 'Red';&#125; 回到目录 避免无意义的条件判断反例:12345678function createMicrobrewery(name) &#123; var breweryName; if (name) &#123; breweryName = name; &#125; else &#123; breweryName = 'Hipster Brew Co.'; &#125;&#125; 正例:123function createMicrobrewery(name) &#123; var breweryName = name || 'Hipster Brew Co.'&#125; 回到目录 函数函数参数 (理想情况下应不超过2个)限制函数参数数量很有必要，这么做使得在测试函数时更加轻松。过多的参数将导致难以采用有效的测试用例对函数的各个参数进行测试。 应避免三个以上参数的函数。通常情况下，参数超过两个意味着函数功能过于复杂，这时需要重新优化你的函数。当确实需要多个参数时，大多情况下可以考虑这些参数封装成一个对象。 JS定义对象非常方便，当需要多个参数时，可以使用一个对象进行替代。 反例:123function createMenu(title, body, buttonText, cancellable) &#123; ...&#125; 正例:12345678910var menuConfig = &#123; title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true&#125;function createMenu(menuConfig) &#123; ...&#125; 回到目录 函数功能的单一性这是软件功能中最重要的原则之一。 功能不单一的函数将导致难以重构、测试和理解。功能单一的函数易于重构，并使代码更加干净。 反例:12345678function emailClients(clients) &#123; clients.forEach(client =&gt; &#123; let clientRecord = database.lookup(client); if (clientRecord.isActive()) &#123; email(client); &#125; &#125;);&#125; 正例:12345678910111213141516function emailClients(clients) &#123; clients.forEach(client =&gt; &#123; emailClientIfNeeded(client); &#125;);&#125;function emailClientIfNeeded(client) &#123; if (isClientActive(client)) &#123; email(client); &#125;&#125;function isClientActive(client) &#123; let clientRecord = database.lookup(client); return clientRecord.isActive();&#125; 回到目录 函数名应明确表明其功能反例:1234567function dateAdd(date, month) &#123; // ...&#125;let date = new Date();// 很难理解dateAdd(date, 1)是什么意思 正例:123456function dateAddMonth(date, month) &#123; // ...&#125;let date = new Date();dateAddMonth(date, 1); 回到目录 函数应该只做一层抽象当函数的需要的抽象多余一层时通常意味着函数功能过于复杂，需将其进行分解以提高其可重用性和可测试性。 反例:12345678910111213141516171819202122function parseBetterJSAlternative(code) &#123; let REGEXES = [ // ... ]; let statements = code.split(' '); let tokens; REGEXES.forEach((REGEX) =&gt; &#123; statements.forEach((statement) =&gt; &#123; // ... &#125;) &#125;); let ast; tokens.forEach((token) =&gt; &#123; // lex... &#125;); ast.forEach((node) =&gt; &#123; // parse... &#125;)&#125; 正例:1234567891011121314151617181920212223242526272829303132function tokenize(code) &#123; let REGEXES = [ // ... ]; let statements = code.split(' '); let tokens; REGEXES.forEach((REGEX) =&gt; &#123; statements.forEach((statement) =&gt; &#123; // ... &#125;) &#125;); return tokens;&#125;function lexer(tokens) &#123; let ast; tokens.forEach((token) =&gt; &#123; // lex... &#125;); return ast;&#125;function parseBetterJSAlternative(code) &#123; let tokens = tokenize(code); let ast = lexer(tokens); ast.forEach((node) =&gt; &#123; // parse... &#125;)&#125; 回到目录 移除重复的代码永远、永远、永远不要在任何循环下有重复的代码。 这种做法毫无意义且潜在危险极大。重复的代码意味着逻辑变化时需要对不止一处进行修改。JS弱类型的特点使得函数拥有更强的普适性。好好利用这一优点吧。 反例:1234567891011121314151617181920212223242526272829function showDeveloperList(developers) &#123; developers.forEach(developers =&gt; &#123; var expectedSalary = developer.calculateExpectedSalary(); var experience = developer.getExperience(); var githubLink = developer.getGithubLink(); var data = &#123; expectedSalary: expectedSalary, experience: experience, githubLink: githubLink &#125;; render(data); &#125;);&#125;function showManagerList(managers) &#123; managers.forEach(manager =&gt; &#123; var expectedSalary = manager.calculateExpectedSalary(); var experience = manager.getExperience(); var portfolio = manager.getMBAProjects(); var data = &#123; expectedSalary: expectedSalary, experience: experience, portfolio: portfolio &#125;; render(data); &#125;);&#125; 正例:123456789101112131415161718192021function showList(employees) &#123; employees.forEach(employee =&gt; &#123; var expectedSalary = employee.calculateExpectedSalary(); var experience = employee.getExperience(); var portfolio; if (employee.type === 'manager') &#123; portfolio = employee.getMBAProjects(); &#125; else &#123; portfolio = employee.getGithubLink(); &#125; var data = &#123; expectedSalary: expectedSalary, experience: experience, portfolio: portfolio &#125;; render(data); &#125;);&#125; 回到目录 采用默认参数精简代码反例:1234function writeForumComment(subject, body) &#123; subject = subject || 'No Subject'; body = body || 'No text';&#125; 正例:123function writeForumComment(subject = 'No subject', body = 'No text') &#123; ...&#125; 回到目录 使用Object.assign设置默认对象反例:12345678910111213141516var menuConfig = &#123; title: null, body: 'Bar', buttonText: null, cancellable: true&#125;function createMenu(config) &#123; config.title = config.title || 'Foo' config.body = config.body || 'Bar' config.buttonText = config.buttonText || 'Baz' config.cancellable = config.cancellable === undefined ? config.cancellable : true;&#125;createMenu(menuConfig); 正例:1234567891011121314151617181920var menuConfig = &#123; title: 'Order', // User did not include 'body' key buttonText: 'Send', cancellable: true&#125;function createMenu(config) &#123; config = Object.assign(&#123; title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true &#125;, config); // config now equals: &#123;title: \"Foo\", body: \"Bar\", buttonText: \"Baz\", cancellable: true&#125; // ...&#125;createMenu(menuConfig); 回到目录 不要使用标记(Flag)作为函数参数这通常意味着函数的功能的单一性已经被破坏。此时应考虑对函数进行再次划分。 反例:1234567function createFile(name, temp) &#123; if (temp) &#123; fs.create('./temp/' + name); &#125; else &#123; fs.create(name); &#125;&#125; 正例:1234567function createTempFile(name) &#123; fs.create('./temp/' + name);&#125;function createFile(name) &#123; fs.create(name);&#125; 回到目录 避免副作用当函数产生了除了“接受一个值并返回一个结果”之外的行为时，称该函数产生了副作用。比如写文件、修改全局变量或将你的钱全转给了一个陌生人等。 程序在某些情况下确实需要副作用这一行为，如先前例子中的写文件。这时应该将这些功能集中在一起，不要用多个函数/类修改某个文件。用且只用一个service完成这一需求。 反例:1234567891011// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.var name = 'Ryan McDermott';function splitIntoFirstAndLastName() &#123; name = name.split(' ');&#125;splitIntoFirstAndLastName();console.log(name); // ['Ryan', 'McDermott']; 正例:123456789function splitIntoFirstAndLastName(name) &#123; return name.split(' ');&#125;var name = 'Ryan McDermott'var newName = splitIntoFirstAndLastName(name);console.log(name); // 'Ryan McDermott';console.log(newName); // ['Ryan', 'McDermott']; 回到目录 不要写全局函数在JS中污染全局是一个非常不好的实践，这么做可能和其他库起冲突，且调用你的API的用户在实际环境中得到一个exception前对这一情况是一无所知的。 想象以下例子：如果你想扩展JS中的Array，为其添加一个diff函数显示两个数组间的差异，此时应如何去做？你可以将diff写入Array.prototype，但这么做会和其他有类似需求的库造成冲突。如果另一个库对diff的需求为比较一个数组中收尾元素间的差异呢？ 使用ES6中的class对全局的Array做简单的扩展显然是一个更棒的选择。 反例:12345678910111213141516Array.prototype.diff = function(comparisonArray) &#123; var values = []; var hash = &#123;&#125;; for (var i of comparisonArray) &#123; hash[i] = true; &#125; for (var i of this) &#123; if (!hash[i]) &#123; values.push(i); &#125; &#125; return values;&#125; 正例:12345678910111213141516171819202122class SuperArray extends Array &#123; constructor(...args) &#123; super(...args); &#125; diff(comparisonArray) &#123; var values = []; var hash = &#123;&#125;; for (var i of comparisonArray) &#123; hash[i] = true; &#125; for (var i of this) &#123; if (!hash[i]) &#123; values.push(i); &#125; &#125; return values; &#125;&#125; 回到目录 采用函数式编程函数式的编程具有更干净且便于测试的特点。尽可能的使用这种风格吧。 反例:123456789101112131415161718192021const programmerOutput = [ &#123; name: 'Uncle Bobby', linesOfCode: 500 &#125;, &#123; name: 'Suzie Q', linesOfCode: 1500 &#125;, &#123; name: 'Jimmy Gosling', linesOfCode: 150 &#125;, &#123; name: 'Gracie Hopper', linesOfCode: 1000 &#125;];var totalOutput = 0;for (var i = 0; i &lt; programmerOutput.length; i++) &#123; totalOutput += programmerOutput[i].linesOfCode;&#125; 正例:12345678910111213141516171819const programmerOutput = [ &#123; name: 'Uncle Bobby', linesOfCode: 500 &#125;, &#123; name: 'Suzie Q', linesOfCode: 1500 &#125;, &#123; name: 'Jimmy Gosling', linesOfCode: 150 &#125;, &#123; name: 'Gracie Hopper', linesOfCode: 1000 &#125;];var totalOutput = programmerOutput .map((programmer) =&gt; programmer.linesOfCode) .reduce((acc, linesOfCode) =&gt; acc + linesOfCode, 0); 回到目录 封装判断条件反例:123if (fsm.state === 'fetching' &amp;&amp; isEmpty(listNode)) &#123; /// ...&#125; 正例:1234567function shouldShowSpinner(fsm, listNode) &#123; return fsm.state === 'fetching' &amp;&amp; isEmpty(listNode);&#125;if (shouldShowSpinner(fsmInstance, listNodeInstance)) &#123; // ...&#125; 回到目录 避免“否定情况”的判断反例:1234567function isDOMNodeNotPresent(node) &#123; // ...&#125;if (!isDOMNodeNotPresent(node)) &#123; // ...&#125; 正例:1234567function isDOMNodePresent(node) &#123; // ...&#125;if (isDOMNodePresent(node)) &#123; // ...&#125; 回到目录 避免条件判断这看起来似乎不太可能。 大多人听到这的第一反应是：“怎么可能不用if完成其他功能呢？”许多情况下通过使用多态(polymorphism)可以达到同样的目的。 第二个问题在于采用这种方式的原因是什么。答案是我们之前提到过的：保持函数功能的单一性。 反例:12345678910111213class Airplane &#123; //... getCruisingAltitude() &#123; switch (this.type) &#123; case '777': return getMaxAltitude() - getPassengerCount(); case 'Air Force One': return getMaxAltitude(); case 'Cessna': return getMaxAltitude() - getFuelExpenditure(); &#125; &#125;&#125; 正例:123456789101112131415161718192021222324class Airplane &#123; //...&#125;class Boeing777 extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude() - getPassengerCount(); &#125;&#125;class AirForceOne extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude(); &#125;&#125;class Cessna extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude() - getFuelExpenditure(); &#125;&#125; 回到目录 避免类型判断(part 1)JS是弱类型语言，这意味着函数可接受任意类型的参数。 有时这会对你带来麻烦，你会对参数做一些类型判断。有许多方法可以避免这些情况。 反例:1234567function travelToTexas(vehicle) &#123; if (vehicle instanceof Bicycle) &#123; vehicle.peddle(this.currentLocation, new Location('texas')); &#125; else if (vehicle instanceof Car) &#123; vehicle.drive(this.currentLocation, new Location('texas')); &#125;&#125; 正例:123function travelToTexas(vehicle) &#123; vehicle.move(this.currentLocation, new Location('texas'));&#125; 回到目录 避免类型判断(part 2)如果需处理的数据为字符串，整型，数组等类型，无法使用多态并仍有必要对其进行类型检测时，可以考虑使用TypeScript。 反例:12345678function combine(val1, val2) &#123; if (typeof val1 == \"number\" &amp;&amp; typeof val2 == \"number\" || typeof val1 == \"string\" &amp;&amp; typeof val2 == \"string\") &#123; return val1 + val2; &#125; else &#123; throw new Error('Must be of type String or Number'); &#125;&#125; 正例:123function combine(val1, val2) &#123; return val1 + val2;&#125; 回到目录 避免过度优化现代的浏览器在运行时会对代码自动进行优化。有时人为对代码进行优化可能是在浪费时间。 这里可以找到许多真正需要优化的地方 反例:1234567// 这里使用变量len是因为在老式浏览器中，// 直接使用正例中的方式会导致每次循环均重复计算list.length的值，// 而在现代浏览器中会自动完成优化，这一行为是没有必要的for (var i = 0, len = list.length; i &lt; len; i++) &#123; // ...&#125; 正例:123for (var i = 0; i &lt; list.length; i++) &#123; // ...&#125; 回到目录 删除无效的代码不再被调用的代码应及时删除。 反例:12345678910function oldRequestModule(url) &#123; // ...&#125;function newRequestModule(url) &#123; // ...&#125;var req = newRequestModule;inventoryTracker('apples', req, 'www.inventory-awesome.io'); 正例:123456function newRequestModule(url) &#123; // ...&#125;var req = newRequestModule;inventoryTracker('apples', req, 'www.inventory-awesome.io'); 回到目录 对象和数据结构使用getters和settersJS没有接口或类型，因此实现这一模式是很困难的，因为我们并没有类似public和private的关键词。 然而，使用getters和setters获取对象的数据远比直接使用点操作符具有优势。为什么呢？ 当需要对获取的对象属性执行额外操作时。 执行set时可以增加规则对要变量的合法性进行判断。 封装了内部逻辑。 在存取时可以方便的增加日志和错误处理。 继承该类时可以重载默认行为。 从服务器获取数据时可以进行懒加载。 反例:12345678910class BankAccount &#123; constructor() &#123; this.balance = 1000; &#125;&#125;let bankAccount = new BankAccount();// Buy shoes...bankAccount.balance = bankAccount.balance - 100; 正例:1234567891011121314151617class BankAccount &#123; constructor() &#123; this.balance = 1000; &#125; // It doesn't have to be prefixed with `get` or `set` to be a getter/setter withdraw(amount) &#123; if (verifyAmountCanBeDeducted(amount)) &#123; this.balance -= amount; &#125; &#125;&#125;let bankAccount = new BankAccount();// Buy shoes...bankAccount.withdraw(100); 回到目录 让对象拥有私有成员可以通过闭包完成 反例:12345678910111213var Employee = function(name) &#123; this.name = name;&#125;Employee.prototype.getName = function() &#123; return this.name;&#125;var employee = new Employee('John Doe');console.log('Employee name: ' + employee.getName()); // Employee name: John Doedelete employee.name;console.log('Employee name: ' + employee.getName()); // Employee name: undefined 正例:1234567891011121314var Employee = (function() &#123; function Employee(name) &#123; this.getName = function() &#123; return name; &#125;; &#125; return Employee;&#125;());var employee = new Employee('John Doe');console.log('Employee name: ' + employee.getName()); // Employee name: John Doedelete employee.name;console.log('Employee name: ' + employee.getName()); // Employee name: John Doe 回到目录 类单一职责原则 (SRP)如《代码整洁之道》一书中所述，“修改一个类的理由不应该超过一个”。 将多个功能塞进一个类的想法很诱人，但这将导致你的类无法达到概念上的内聚，并经常不得不进行修改。 最小化对一个类需要修改的次数是非常有必要的。如果一个类具有太多太杂的功能，当你对其中一小部分进行修改时，将很难想象到这一修够对代码库中依赖该类的其他模块会带来什么样的影响。 反例:123456789101112131415class UserSettings &#123; constructor(user) &#123; this.user = user; &#125; changeSettings(settings) &#123; if (this.verifyCredentials(user)) &#123; // ... &#125; &#125; verifyCredentials(user) &#123; // ... &#125;&#125; 正例:1234567891011121314151617181920212223class UserAuth &#123; constructor(user) &#123; this.user = user; &#125; verifyCredentials() &#123; // ... &#125;&#125;class UserSettings &#123; constructor(user) &#123; this.user = user; this.auth = new UserAuth(user) &#125; changeSettings(settings) &#123; if (this.auth.verifyCredentials()) &#123; // ... &#125; &#125;&#125; 回到目录 开/闭原则 (OCP)“代码实体(类，模块，函数等)应该易于扩展，难于修改。” 这一原则指的是我们应允许用户方便的扩展我们代码模块的功能，而不需要打开js文件源码手动对其进行修改。 反例:123456789101112class AjaxRequester &#123; constructor() &#123; // What if we wanted another HTTP Method, like DELETE? We would have to // open this file up and modify this and put it in manually. this.HTTP_METHODS = ['POST', 'PUT', 'GET']; &#125; get(url) &#123; // ... &#125;&#125; 正例:12345678910111213class AjaxRequester &#123; constructor() &#123; this.HTTP_METHODS = ['POST', 'PUT', 'GET']; &#125; get(url) &#123; // ... &#125; addHTTPMethod(method) &#123; this.HTTP_METHODS.push(method); &#125;&#125; 回到目录 利斯科夫替代原则 (LSP)“子类对象应该能够替换其超类对象被使用”。 也就是说，如果有一个父类和一个子类，当采用子类替换父类时不应该产生错误的结果。 反例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Rectangle &#123; constructor() &#123; this.width = 0; this.height = 0; &#125; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125; setWidth(width) &#123; this.width = width; &#125; setHeight(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Rectangle &#123; constructor() &#123; super(); &#125; setWidth(width) &#123; this.width = width; this.height = width; &#125; setHeight(height) &#123; this.width = height; this.height = height; &#125;&#125;function renderLargeRectangles(rectangles) &#123; rectangles.forEach((rectangle) =&gt; &#123; rectangle.setWidth(4); rectangle.setHeight(5); let area = rectangle.getArea(); // BAD: Will return 25 for Square. Should be 20. rectangle.render(area); &#125;)&#125;let rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles); 正例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Shape &#123; constructor() &#123;&#125; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125;&#125;class Rectangle extends Shape &#123; constructor() &#123; super(); this.width = 0; this.height = 0; &#125; setWidth(width) &#123; this.width = width; &#125; setHeight(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Shape &#123; constructor() &#123; super(); this.length = 0; &#125; setLength(length) &#123; this.length = length; &#125; getArea() &#123; return this.length * this.length; &#125;&#125;function renderLargeShapes(shapes) &#123; shapes.forEach((shape) =&gt; &#123; switch (shape.constructor.name) &#123; case 'Square': shape.setLength(5); case 'Rectangle': shape.setWidth(4); shape.setHeight(5); &#125; let area = shape.getArea(); shape.render(area); &#125;)&#125;let shapes = [new Rectangle(), new Rectangle(), new Square()];renderLargeShapes(shapes); 回到目录 接口隔离原则 (ISP)“客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。” 在JS中，当一个类需要许多参数设置才能生成一个对象时，或许大多时候不需要设置这么多的参数。此时减少对配置参数数量的需求是有益的。 反例:123456789101112131415161718192021class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.animationModule.setup(); &#125; traverse() &#123; // ... &#125;&#125;let $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName('body'), animationModule: function() &#123;&#125; // Most of the time, we won't need to animate when traversing. // ...&#125;); 正例:1234567891011121314151617181920212223242526272829class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.options = settings.options; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.setupOptions(); &#125; setupOptions() &#123; if (this.options.animationModule) &#123; // ... &#125; &#125; traverse() &#123; // ... &#125;&#125;let $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName('body'), options: &#123; animationModule: function() &#123;&#125; &#125;&#125;); 回到目录 依赖反转原则 (DIP)该原则有两个核心点: 高层模块不应该依赖于低层模块。他们都应该依赖于抽象接口。 抽象接口应该脱离具体实现，具体实现应该依赖于抽象接口。 反例:12345678910111213141516171819202122232425262728class InventoryTracker &#123; constructor(items) &#123; this.items = items; // BAD: We have created a dependency on a specific request implementation. // We should just have requestItems depend on a request method: `request` this.requester = new InventoryRequester(); &#125; requestItems() &#123; this.items.forEach((item) =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;class InventoryRequester &#123; constructor() &#123; this.REQ_METHODS = ['HTTP']; &#125; requestItem(item) &#123; // ... &#125;&#125;let inventoryTracker = new InventoryTracker(['apples', 'bananas']);inventoryTracker.requestItems(); 正例:12345678910111213141516171819202122232425262728293031323334353637class InventoryTracker &#123; constructor(items, requester) &#123; this.items = items; this.requester = requester; &#125; requestItems() &#123; this.items.forEach((item) =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;class InventoryRequesterV1 &#123; constructor() &#123; this.REQ_METHODS = ['HTTP']; &#125; requestItem(item) &#123; // ... &#125;&#125;class InventoryRequesterV2 &#123; constructor() &#123; this.REQ_METHODS = ['WS']; &#125; requestItem(item) &#123; // ... &#125;&#125;// By constructing our dependencies externally and injecting them, we can easily// substitute our request module for a fancy new one that uses WebSockets.let inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());inventoryTracker.requestItems(); 回到目录 使用ES6的classes而不是ES5的Function典型的ES5的类(function)在继承、构造和方法定义方面可读性较差。 当需要继承时，优先选用classes。 但是，当在需要更大更复杂的对象时，最好优先选择更小的function而非classes。 反例:1234567891011121314151617181920212223242526272829303132333435var Animal = function(age) &#123; if (!(this instanceof Animal)) &#123; throw new Error(\"Instantiate Animal with `new`\"); &#125; this.age = age;&#125;;Animal.prototype.move = function() &#123;&#125;;var Mammal = function(age, furColor) &#123; if (!(this instanceof Mammal)) &#123; throw new Error(\"Instantiate Mammal with `new`\"); &#125; Animal.call(this, age); this.furColor = furColor;&#125;;Mammal.prototype = Object.create(Animal.prototype);Mammal.prototype.constructor = Mammal;Mammal.prototype.liveBirth = function() &#123;&#125;;var Human = function(age, furColor, languageSpoken) &#123; if (!(this instanceof Human)) &#123; throw new Error(\"Instantiate Human with `new`\"); &#125; Mammal.call(this, age, furColor); this.languageSpoken = languageSpoken;&#125;;Human.prototype = Object.create(Mammal.prototype);Human.prototype.constructor = Human;Human.prototype.speak = function() &#123;&#125;; 正例:12345678910111213141516171819202122232425class Animal &#123; constructor(age) &#123; this.age = age; &#125; move() &#123;&#125;&#125;class Mammal extends Animal &#123; constructor(age, furColor) &#123; super(age); this.furColor = furColor; &#125; liveBirth() &#123;&#125;&#125;class Human extends Mammal &#123; constructor(age, furColor, languageSpoken) &#123; super(age, furColor); this.languageSpoken = languageSpoken; &#125; speak() &#123;&#125;&#125; 回到目录 使用方法链这里我们的理解与《代码整洁之道》的建议有些不同。 有争论说方法链不够干净且违反了德米特法则,也许这是对的，但这种方法在JS及许多库(如JQuery)中显得非常实用。 因此，我认为在JS中使用方法链是非常合适的。在class的函数中返回this，能够方便的将类需要执行的多个方法链接起来。 反例:1234567891011121314151617181920212223242526272829class Car &#123; constructor() &#123; this.make = 'Honda'; this.model = 'Accord'; this.color = 'white'; &#125; setMake(make) &#123; this.name = name; &#125; setModel(model) &#123; this.model = model; &#125; setColor(color) &#123; this.color = color; &#125; save() &#123; console.log(this.make, this.model, this.color); &#125;&#125;let car = new Car();car.setColor('pink');car.setMake('Ford');car.setModel('F-150')car.save(); 正例:1234567891011121314151617181920212223242526272829303132333435class Car &#123; constructor() &#123; this.make = 'Honda'; this.model = 'Accord'; this.color = 'white'; &#125; setMake(make) &#123; this.name = name; // NOTE: Returning this for chaining return this; &#125; setModel(model) &#123; this.model = model; // NOTE: Returning this for chaining return this; &#125; setColor(color) &#123; this.color = color; // NOTE: Returning this for chaining return this; &#125; save() &#123; console.log(this.make, this.model, this.color); &#125;&#125;let car = new Car() .setColor('pink') .setMake('Ford') .setModel('F-150') .save(); 回到目录 优先使用组合模式而非继承在著名的设计模式一书中提到，应多使用组合模式而非继承。 这么做有许多优点，在想要使用继承前，多想想能否通过组合模式满足需求吧。 那么，在什么时候继承具有更大的优势呢？这取决于你的具体需求，但大多情况下，可以遵守以下三点： 继承关系表现为”是一个”而非”有一个”(如动物-&gt;人 和 用户-&gt;用户细节) 可以复用基类的代码(“Human”可以看成是”All animal”的一种) 希望当基类改变时所有派生类都受到影响(如修改”all animals”移动时的卡路里消耗量) 反例:12345678910111213141516171819class Employee &#123; constructor(name, email) &#123; this.name = name; this.email = email; &#125; // ...&#125;// Bad because Employees \"have\" tax data. EmployeeTaxData is not a type of Employeeclass EmployeeTaxData extends Employee &#123; constructor(ssn, salary) &#123; super(); this.ssn = ssn; this.salary = salary; &#125; // ...&#125; 正例:123456789101112131415161718192021class Employee &#123; constructor(name, email) &#123; this.name = name; this.email = email; &#125; setTaxData(ssn, salary) &#123; this.taxData = new EmployeeTaxData(ssn, salary); &#125; // ...&#125;class EmployeeTaxData &#123; constructor(ssn, salary) &#123; this.ssn = ssn; this.salary = salary; &#125; // ...&#125; 回到目录 测试一些好的覆盖工具. 一些好的JS测试框架 单一的测试每个概念反例:12345678910111213141516171819const assert = require('assert');describe('MakeMomentJSGreatAgain', function() &#123; it('handles date boundaries', function() &#123; let date; date = new MakeMomentJSGreatAgain('1/1/2015'); date.addDays(30); date.shouldEqual('1/31/2015'); date = new MakeMomentJSGreatAgain('2/1/2016'); date.addDays(28); assert.equal('02/29/2016', date); date = new MakeMomentJSGreatAgain('2/1/2015'); date.addDays(28); assert.equal('03/01/2015', date); &#125;);&#125;); 正例:123456789101112131415161718192021const assert = require('assert');describe('MakeMomentJSGreatAgain', function() &#123; it('handles 30-day months', function() &#123; let date = new MakeMomentJSGreatAgain('1/1/2015'); date.addDays(30); date.shouldEqual('1/31/2015'); &#125;); it('handles leap year', function() &#123; let date = new MakeMomentJSGreatAgain('2/1/2016'); date.addDays(28); assert.equal('02/29/2016', date); &#125;); it('handles non-leap year', function() &#123; let date = new MakeMomentJSGreatAgain('2/1/2015'); date.addDays(28); assert.equal('03/01/2015', date); &#125;);&#125;); 回到目录 并发用Promises替代回调回调不够整洁并会造成大量的嵌套。ES6内嵌了Promises，使用它吧。 反例:1234567891011121314require('request').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin', function(err, response) &#123; if (err) &#123; console.error(err); &#125; else &#123; require('fs').writeFile('article.html', response.body, function(err) &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log('File written'); &#125; &#125;) &#125;&#125;) 正例:12345678910require('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin') .then(function(response) &#123; return require('fs-promise').writeFile('article.html', response); &#125;) .then(function() &#123; console.log('File written'); &#125;) .catch(function(err) &#123; console.error(err); &#125;) 回到目录 Async/Await是较Promises更好的选择Promises是较回调而言更好的一种选择，但ES7中的async和await更胜过Promises。 在能使用ES7特性的情况下可以尽量使用他们替代Promises。 反例:12345678910require('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin') .then(function(response) &#123; return require('fs-promise').writeFile('article.html', response); &#125;) .then(function() &#123; console.log('File written'); &#125;) .catch(function(err) &#123; console.error(err); &#125;) 正例:123456789101112async function getCleanCodeArticle() &#123; try &#123; var request = await require('request-promise') var response = await request.get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin'); var fileHandle = await require('fs-promise'); await fileHandle.writeFile('article.html', response); console.log('File written'); &#125; catch(err) &#123; console.log(err); &#125; &#125; 回到目录 错误处理错误抛出是个好东西！这使得你能够成功定位运行状态中的程序产生错误的位置。 别忘了捕获错误对捕获的错误不做任何处理是没有意义的。 代码中try/catch的意味着你认为这里可能出现一些错误，你应该对这些可能的错误存在相应的处理方案。 反例:12345try &#123; functionThatMightThrow();&#125; catch (error) &#123; console.log(error);&#125; 正例:1234567891011try &#123; functionThatMightThrow();&#125; catch (error) &#123; // One option (more noisy than console.log): console.error(error); // Another option: notifyUserOfError(error); // Another option: reportErrorToService(error); // OR do all three!&#125; 不要忽略被拒绝的promises理由同try/catch. 反例:1234567getdata().then(data =&gt; &#123; functionThatMightThrow(data);&#125;).catch(error =&gt; &#123; console.log(error);&#125;); 正例:12345678910111213getdata().then(data =&gt; &#123; functionThatMightThrow(data);&#125;).catch(error =&gt; &#123; // One option (more noisy than console.log): console.error(error); // Another option: notifyUserOfError(error); // Another option: reportErrorToService(error); // OR do all three!&#125;); 回到目录 格式化格式化是一件主观的事。如同这里的许多规则一样，这里并没有一定/立刻需要遵守的规则。可以在这里完成格式的自动化。 大小写一致JS是弱类型语言，合理的采用大小写可以告诉你关于变量/函数等的许多消息。 这些规则是主观定义的，团队可以根据喜欢进行选择。重点在于无论选择何种风格，都需要注意保持一致性。 反例:1234567891011var DAYS_IN_WEEK = 7;var daysInMonth = 30;var songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];var Artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];function eraseDatabase() &#123;&#125;function restore_database() &#123;&#125;class animal &#123;&#125;class Alpaca &#123;&#125; 正例:1234567891011var DAYS_IN_WEEK = 7;var DAYS_IN_MONTH = 30;var songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];var artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];function eraseDatabase() &#123;&#125;function restoreDatabase() &#123;&#125;class Animal &#123;&#125;class Alpaca &#123;&#125; 回到目录 调用函数的函数和被调函数应放在较近的位置当函数间存在相互调用的情况时，应将两者置于较近的位置。 理想情况下，应将调用其他函数的函数写在被调用函数的上方。 反例:1234567891011121314151617181920212223242526272829303132333435class PerformanceReview &#123; constructor(employee) &#123; this.employee = employee; &#125; lookupPeers() &#123; return db.lookup(this.employee, 'peers'); &#125; lookupMananger() &#123; return db.lookup(this.employee, 'manager'); &#125; getPeerReviews() &#123; let peers = this.lookupPeers(); // ... &#125; perfReview() &#123; getPeerReviews(); getManagerReview(); getSelfReview(); &#125; getManagerReview() &#123; let manager = this.lookupManager(); &#125; getSelfReview() &#123; // ... &#125;&#125;let review = new PerformanceReview(user);review.perfReview(); 正例:1234567891011121314151617181920212223242526272829303132333435class PerformanceReview &#123; constructor(employee) &#123; this.employee = employee; &#125; perfReview() &#123; getPeerReviews(); getManagerReview(); getSelfReview(); &#125; getPeerReviews() &#123; let peers = this.lookupPeers(); // ... &#125; lookupPeers() &#123; return db.lookup(this.employee, 'peers'); &#125; getManagerReview() &#123; let manager = this.lookupManager(); &#125; lookupMananger() &#123; return db.lookup(this.employee, 'manager'); &#125; getSelfReview() &#123; // ... &#125;&#125;let review = new PerformanceReview(employee);review.perfReview(); 回到目录 注释只对存在一定业务逻辑复制性的代码进行注释注释并不是必须的，好的代码是能够让人一目了然，不用过多无谓的注释。 反例:1234567891011121314151617function hashIt(data) &#123; // The hash var hash = 0; // Length of string var length = data.length; // Loop through every character in data for (var i = 0; i &lt; length; i++) &#123; // Get character code. var char = data.charCodeAt(i); // Make the hash hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; &#125;&#125; 正例:12345678910111213function hashIt(data) &#123; var hash = 0; var length = data.length; for (var i = 0; i &lt; length; i++) &#123; var char = data.charCodeAt(i); hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; &#125;&#125; 回到目录 不要在代码库中遗留被注释掉的代码版本控制的存在是有原因的。让旧代码存在于你的history里吧。 反例:1234doStuff();// doOtherStuff();// doSomeMoreStuff();// doSoMuchStuff(); 正例:1doStuff(); 回到目录 不需要版本更新类型注释记住，我们可以使用版本控制。废代码、被注释的代码及用注释记录代码中的版本更新说明都是没有必要的。 需要时可以使用git log获取历史版本。 反例:123456789/** * 2016-12-20: Removed monads, didn't understand them (RM) * 2016-10-01: Improved using special monads (JP) * 2016-02-03: Removed type-checking (LI) * 2015-03-14: Added combine with type-checking (JR) */function combine(a, b) &#123; return a + b;&#125; 正例:123function combine(a, b) &#123; return a + b;&#125; 回到目录 避免位置标记这些东西通常只能代码麻烦，采用适当的缩进就可以了。 反例:1234567891011121314////////////////////////////////////////////////////////////////////////////////// Scope Model Instantiation////////////////////////////////////////////////////////////////////////////////let $scope.model = &#123; menu: 'foo', nav: 'bar'&#125;;////////////////////////////////////////////////////////////////////////////////// Action setup////////////////////////////////////////////////////////////////////////////////let actions = function() &#123; // ...&#125; 正例:12345678let $scope.model = &#123; menu: 'foo', nav: 'bar'&#125;;let actions = function() &#123; // ...&#125; 回到目录 避免在源文件中写入法律评论将你的LICENSE文件置于源码目录树的根目录。 反例:123456789101112131415161718192021222324252627/*The MIT License (MIT)Copyright (c) 2016 Ryan McDermottPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the \"Software\"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE*/function calculateBill() &#123; // ...&#125; 正例:123function calculateBill() &#123; // ...&#125; 回到目录 转载：https://github.com/ZetaoYang/clean-code-js","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuyouyou.github.io/tags/JavaScript/"}]},{"title":"降低网页加载时间","date":"2017-03-15T07:36:18.000Z","path":"2017/03/15/ninth-article/","text":"降低网页加载时间的方案太多了，在网上一查多的看不过来，所以我结合自身用到的以及网上的方案，来归纳一下吧，主要是一些前端能做的事情，以后get到新的方案，再不断添加吧。(╯▽╰)其实网页加载就是请求HTML，再顺带将它依赖的资源文件（比如：JS/CSS/iconfont）一并请求过来。从概念出发，我们就可以得出降低网页加载时间，最本质的方式就是：减少请求数量 与 减小请求大小。一、减少请求数量 优化图像1、将小图标合并成sprite图我们可以把多张背景图片和小图标合并雪碧图，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数。2、使用iconfont字体图标sprite图不适合无线端的响应式场景，所以越来越作为一个备用方案，而很多时候可以用iconfont字体来代替一些小图标。它就是用字体编码的形式来实现图标效果，既然是文字，那就可以随意设置颜色设置大小，相对来说比sprite方案更好，但是它只适用于纯色图标。3、base64:URL背景图片使用base64图可以减少HTTP请求，还可以避免跨域的问题。不了解的可以直接点击：详情传送门4、图片延迟加载图片延迟加载也称懒加载，常用于页面很长，图片很多的页面，整个页面少说几百K，多则上兆，如果想一次性加载完成，不仅用户要哭了，服务器也得哭了。为了避免这种请况发生，目前主流的做法是页面初次加载时，只显示当前可视区域的图片，当用户滚动页面的时候，当图片进入可视区域时再加载，这样可以明显的提高页面加载速度，而更少的图片并发请求数，也可以大大的减轻服务器的压力。5、标明图片高度和宽度如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。 Ajax调用尽量采用GET方法实际使用XMLHttpRequest时，如果使用POST方法实现，会发生2次HTTP请求，而使用GET方法只会发生1次HTTP请求。如果改用GET方法，HTTP请求减少50%。 避免使用@importcss @import语法允许你加载其它的CSS文件。有时非常有帮助，但是它并不是和主文件一起下载的，只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作，因此css @import引起的css解析延迟会加长页面留白期。 所以，要尽量避免使用css @import而采用link标签的方式引入。 二、减小请求大小 JS/CSS/HTML压缩很多公司都采用了这个手段，就不介绍太多，主要的方式有：1、通过构建工具实现，比如webpack/gulp/fis/grunt等。2、后台预编译。3、利用第三方online平台，手动上传压缩。 图片压缩同上可以手动处理图片或者借助第三方平台，手动处理的话推荐一个网站 tinypng，或者用第三方平台，比如七牛云平台。 三、其他方案 利用浏览器缓存浏览器缓存是允许访客的浏览器缓存你网站页面副本的一个功能。这有助于访客再次访问时，直接从缓存中读取内容而不必重新加载。这节省了向服务器发送HTTP请求的时间。 网址后加斜杠当用户打开一个链接时，服务器会推测链接这个地址包含哪种文件或页面。如果在连接后加上斜线（ / ），服务器就知道这是一个目录页，这样做可以减少页面的加载时间。如www.baidu.com/目录，会判断这个“目录是什么文件类型，或者是目录。 添加文件过期或缓存头同一用户频繁访问的图片、Js脚本文件等可以在Apache或Nginx设置其缓冲 时间，例如设置24小时过期时间，这样用户在访问过该页面之后再次访问时，同一组图片或JS不会再重复下载，从而减少了HTTP请求，用户访问速度明显有 所提升，同时服务器负载也会下降。 减少DNS查询减少DNS查询是一个WEB开发人员可以用了页面加载时间快速有效的方法。DNS查询需要话费很长的时间来返回一个主机名的IP地址。而浏览器在查询结束前不会进行任何操作。对于不同的元素可以使用不同的主机名，如URL、图像、脚本文件、样式文件、FLASH元素等。具有多种网络元素的页面经常需要进行多个DNS查询，因而花费的时间更长。减少不同域名的数量将减少并行下载的数量，加速你的网站。 最小化重定向重定向增加了额外的HTTP请求，因此也增加了页面加载时间。然而有时重定向却是不可避免的，如链接网站的不同部分、保存多个域名、或者从不存在的页面跳转到新页面。重定向增加了延迟时间，因此要尽量避免使用它。检查是否有损坏的链接，并立即修复。 CSS和JS的文件位置把CSS文件在页面底部引入可以禁止逐步渲染，节省浏览器加载和重绘页面元素的资源。把JS文件放在页面底部可以避免代码执行前的等待时间，从而提升页面加载速度。但是在某些情况下，需要JS在页面的顶部加载（如某些第三方跟踪脚本）。 延迟加载ga统计ga统计代码不阻塞页面渲染，不阻塞后续请求，但会阻塞window.onload事件，页面的表现方式是进度条一直加载。所以我们延迟执行ga初始化代码，将其放到window.onload函数中去执行，可以防止ga脚本阻塞window.onload事件。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yuyouyou.github.io/tags/性能优化/"}]},{"title":"函数节流与防抖","date":"2017-03-13T02:04:25.000Z","path":"2017/03/13/eighth-article/","text":"函数节流我们网站经常会有这样的需求，就是滚动浏览器滚动条的时候，更新页面上的某些布局内容或者去调用后台的某接口查询内容。如果不对函数调用的频率加以限制的话，那么可能我们滚动一次滚动条就会产生N次的调用了。所以我们每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。为了更好的理解这个概念，我们先来完成一个小需求，就是浏览器滚动条在滚动过程中打印n值：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;函数节流与防抖&lt;/title&gt;&lt;/head&gt;&lt;body style=\"height:1000px\"&gt;&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; window.onscroll=funHandler;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 功能倒是实现了，但是看一下控制台可以发现频繁的在打印n值，如果我们的 funHandler() 方法是 ajax 向服务器发送请求，那还得了啊！ 下面我们利用函数节流的两种方案来完成这个需求：第一种是按照《JavaScript高级程序设计》中的函数节流方法，原理很简单，利用定时器，让函数执行延迟500毫秒，在500毫秒内如果有函数又被调用则删除上一次调用，这次调用500毫秒后执行，如此往复。这样我刚才的代码可以改为：1234567891011121314151617&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; function throttle(method,context)&#123; clearTimeout(method.tId); method.tId=setTimeout(function()&#123; method.call(context); &#125;,500); &#125; window.onscroll=function()&#123; throttle(funHandler,window); &#125;;&lt;/script&gt; 滚动一下试试，果真只执行了一次 第二种是网上的一种节流方案，调试一下试试，效果和刚才是一样的：123456789101112131415161718&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; function throttle(method,delay)&#123; var timer=null; return function()&#123; var context=this, args=arguments; clearTimeout(timer); timer=setTimeout(function()&#123; method.apply(context,args); &#125;,delay); &#125; &#125; window.onscroll=throttle(funHandler,500);&lt;/script&gt; 函数防抖再来一个类似的需求，就像百度首页输入自动提示一样的东西，我在text上绑定keyup事件，每次键盘弹起的时候自动提示，但是又不想提示那么频繁，于是我用了上面方法，但是悲剧了，只有停止输入等500毫秒才会提示，在输入过程中根本就没有提示。看了一下代码，可不是嘛，只要是用户会盲打，在500毫秒内按一下键盘，提示函数就会不断被延迟，这样只有停下来的时候才会提示，这就没意义了。这个时候就用到了函数防抖，函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。其实它是在函数节流的基础上间隔固定时间来执行一次。如下所示：12345678910111213141516171819202122232425262728&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; function throttle(method,delay,duration)&#123; var timer=null, begin=new Date();// 记录下开始执行函数的时间 return function()&#123; var context=this, args=arguments, current=new Date();// 记录下当前时间 // 函数节流里的思路 clearTimeout(timer); // 记录下的两个时间相减再与duration进行比较 if(current-begin&gt;=duration)&#123; method.apply(context,args); begin=current; &#125;else&#123; timer=setTimeout(function()&#123; method.apply(context,args); &#125;,delay); &#125; &#125;&#125; window.onscroll=throttle(funHandler,500,2000);//因为返回函数句柄，不用包装函数了&lt;/script&gt; 这样每次我们判断间隔了多久，要是超过设置时间则立即执行一次，以刚才例子试一试效果，发现果真既没有频繁执行也没有就最后执行，感兴趣的朋友们可以试试哟！","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yuyouyou.github.io/tags/性能优化/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuyouyou.github.io/tags/JavaScript/"}]},{"title":"charles使用教程","date":"2017-03-02T09:20:04.000Z","path":"2017/03/02/seventh-article/","text":"记得我大三的时候有一门课叫计算机网络,是我最喜欢的王勇老师上的,当时勇哥给我们介绍了抓包工具,也是我第一次接触这玩意儿,当时用的wireshark,除了这个工具的名字貌似我什么都不记得了(&gt;_&lt;|||)。当时觉得这个工具应该和我以后的工作没多大联系吧,没想到出来做前端后,经常要用到抓包工具,特别是用来进行前端调试,觉得太赞了,我们可以用本地的文件来替换线上的文件,从而修复一些bug,还可以模拟不同的网络环境,或者设置网络请求。。。推荐一下我常用的两款抓包工具吧,一是fiddler,再就是我接下来介绍的charles。Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。工具就介绍这么多了,接下来介绍一下主要功能吧。 将 Charles 设置成系统代理选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示： 需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。 用 Map 功能来修改服务器返回内容Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。下面我来举一个 “Map Local” 的栗子: 第一步:选择需要抓包的请求,并且保存文件到本地,如下图所示,我们来抓取 http://yuyouyou.github.io/ 下面的main.js文件: 第二步:设置“Map Local”,如下图所示: 第三步:打开刚才抓取的js文件,并且编辑一下再保存,如下图所示: 现在访问 http://yuyouyou.github.io/ 就可以看到修改后的js文件替换了线上的js文件,是不是很酷啊,这对于我们调试线上的文件非常有帮助。 过滤网络请求如果我们需要只监控向指定目录服务器上发送的请求。有以下几种方法： 方法一:在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yuyouyou.github.io/ , 那么只需要在 Filter 栏中填入 yuyouyou 即可。 方法二：在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示： 方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示： 给服务器做压力测试我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力。我们在需要打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。 截取 iPhone 上的网络封包 Charles 上的设置 要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。 iPhone 上的设置首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址。然后,在 iPhone 的 “ 设置 “-&gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888。设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单，点击 “Allow” 即可完成设置。接下来就可以愉快的抓取手机的请求了(^∀^)。 模拟慢速网络在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：","tags":[{"name":"抓包","slug":"抓包","permalink":"http://yuyouyou.github.io/tags/抓包/"},{"name":"网络","slug":"网络","permalink":"http://yuyouyou.github.io/tags/网络/"}]},{"title":"浏览器的重绘与重排","date":"2016-06-08T08:39:04.000Z","path":"2016/06/08/sixth-article/","text":"在前端开发中，性能优化是非常重要的一个环节，而谈到性能优化，我们就不得不了解一下浏览器的重绘与重排概念。 通常在 文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属 性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再 根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次 计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。 重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。 重排是更明显的一种改变，可以理解为渲染树需要重新计算。下面是常见的触发重排的操作： DOM元素的几何属性变化 当DOM元素的几何属性变化时，渲染树中的相关节点就会失效，浏览器会根据DOM元素的变化重新构建渲染树中失效的节点。之后，会根据新的渲染 树重新绘制这部分页面。而且，当前元素的重排也许会带来相关元素的重排。例如，容器节点的渲染树改变时，会触发子节点的重新计算，也会触发其后续兄弟节点 的重排，祖先节点需要重新计算子节点的尺寸也会产生重排。最后，每个元素都将发生重绘。可见，重排一定会引起浏览器的重绘，一个元素的重排通常会带来一系 列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。 DOM树的结构变化 当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器引擎布局的过程，类似于树的前序遍历，是一个从上到下从左到右的过程。 通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。所以，如果在body最前面插入一个元素，会导致整个文档的重新渲染，而在其后插入一个元 素，则不会影响到前面的元素。 获取某些属性 浏览器引擎可能会针对重排做了优化。比如Opera，它会等到有足够数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这 样就只发生一次重排。但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包 括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。 开发中，比较好的实践是尽量减少重排次数和缩小重排的影响范围。例如： 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。 需要多次重排的元素，position值最好为absolute或者fix，让它脱离文档流，这样就不会影响其他元素。所以有动画效果的元素最好设置绝对定位。 将多次改变样式属性的操作合并为一次操作，也就是将需要改变的的样式写在css中，并给一个类名，在js中只需要改变className即可。 由于display为none的元素不再渲染树中，对隐藏元素的操作不会引发其他元素的重排。如果要对一个元素进行复杂操作，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。 需要增加多个节点，可以一次性构建一个html片段，然后一次性添加到文档中去，而不是循环添加每一行。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yuyouyou.github.io/tags/性能优化/"}]},{"title":"windows下MongoDB的安装及配置","date":"2016-04-05T05:49:50.000Z","path":"2016/04/05/fifth-article/","text":"1、进入mongodb官网进行软件包下载。 2、选择windows平台，如图所示： 3、将zip文件解压放到盘符的根目录（如C：或D：），为了方便建议文件夹命名尽量简短如（d:\\mongodb）。 4、创建数据库文件的存放位置，比如d:/mongodb/data/db。启动mongodb服务之前必须创建数据库文件的存放文件夹，否则命令不会自动创建，而且不能启动成功。 5、打开cmd命令行，进入D:\\mongodb\\bin目录，输入如下的命令启动mongodb服务：1D:/mongodb/bin&gt;mongod --dbpath D:\\mongodb\\data\\db 6、mongodb默认连接端口27017，如果出现如图的情况，可以打开localhost:27017查看，发现如图则表示连接成功，如果不成功，可以查看端口是否被占用。 7、其实可以将MongoDB设置成Windows服务，这样每次开机MongoDB就自动启动了。 如图在d:\\mongodb\\data下新建文件夹log（存放日志文件）并且新建文件mongodb.log，在d:\\mongodb新建文件mongo.config。 8、用记事本打开mongo.config输入：12dbpath=D:\\mongodb\\data\\dblogpath=D:\\mongodb\\data\\log\\mongo.log 9、用管理员身份打开cmd命令行，进入D:\\mongodb\\bin目录，输入如下的命令：1D:\\mongodb\\bin&gt;mongod --config D:\\mongodb\\mongo.config 如果不成功可以改为如下：1mongod --config D:\\mongodb\\mongo.config --install --serviceName \"MongoDB\" 进入日志文件，查看日志发现已经成功了。如果失败有可能没有使用管理员身份，遭到拒绝访问。 10、打开cmd输入services.msc查看服务可以看到MongoDB服务，点击可以启动。如下所示：","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yuyouyou.github.io/tags/MongoDB/"}]},{"title":"smarty笔记(待续...)","date":"2016-03-23T10:19:51.000Z","path":"2016/03/23/fourth-article/","text":"日期格式 12345678910111213141516171819&#123;%$time|date_format:'%Y-%m-%d'%&#125; 格式为2016-08-03&#123;%$time|date_format:'%H:%M:%S'%&#125; 格式为14:33:00常见的：%Y 年, 数字, 4 位%y 年, 数字, 2 位%m 月份, 数字(01……12)%c 月份, 数字(1……12)%b 缩写的月份名字(Jan……Dec)%d 月份中的天数, 数字(00……31)%e 月份中的天数, 数字(0……31)%H 小时(00……23)%k 小时(0……23)%I 小时(01……12)%l 小时(1……12)%M 分钟(00……59)%S 秒(00……59)%w 星期名字(Sunday……Saturday)%a 缩写的星期名字(Sun……Sat) 取循环中的特殊地方 12345678910such as:&#123;%foreach $item.tags as $tag name=tags%&#125; &#123;%if $smarty.foreach.tags.last%&#125;,&#123;%/if%&#125;&#123;%/foreach%&#125;index表示当前数组索引，从0开始计算iteration表示当前循环次数，从1开始计算first表示第一个last表示最后一个total表示循环总次数 strip去除多余空格 123456$articleTitle=‘Grandmother of\\neight makes\\t hole in one.’&#123;%$articleTitle%&#125; Grandmother of eight makes hole in one.&#123;%$articleTitle|strip%&#125; Grandmother of eight makes hole in one.&#123;%$articleTitle|strip:\"&amp;nbsp;\"%&#125; Grandmother&amp;nbsp;of&amp;nbsp;eight&amp;nbsp;makes&amp;nbsp;hole&amp;nbsp;in&amp;nbsp;one. strip_tags去除html标签 1234$articleTitle=‘Blind Woman Gets &lt;font face=\\\"helvetica\\\"&gt;New Kidney&lt;/font&gt; from Dad she Hasn't Seen in &lt;b&gt;years&lt;/b&gt;.’&#123;%$articleTitle%&#125; Blind Woman Gets &lt;font face=\"helvetica\"&gt;New Kidney&lt;/font&gt; from Dad she Hasn't Seen in &lt;b&gt;years&lt;/b&gt;.&#123;%$articleTitle|strip_tags%&#125; Blind Woman Gets New Kidney from Dad she Hasn't Seen in years. assign 为模板变量赋值 1234&#123;%assign var=\"name\" value=\"Bob\"%&#125;The value of $name is &#123;$name&#125;.The value of $name is Bob. string_format 字符串格式化（保留小数位） 123&#123;%$number%&#125; 23.5787446&#123;%$number|string_format:\"%.2f\"%&#125; 23.58&#123;%$number|string_format:\"%d\"%&#125; 24 default设置默认值 1&#123;%$user.name|default:'暂无'%&#125; replace 替换 1234$tags=\"设计，音乐\"&#123;$tags&#125; 设计，音乐&#123;$tags|replace:\"，\":\",\"&#125; 设计,音乐 section,sectionelse遍历数组中的数据 它的属性分别是：name表示循环的名称，loop决定循环次数的变量名称或者直接给定循环次数（loop=3），start表示循环执行的初始位置. 如果该值为负数，开始位置从数组的尾部算起，step决定循环的步长， 例如指定step=2将只遍历下标为0、2、4等的元素，max表示循环最大执行次数，show决定是否显示该循环。 12345&#123;section name=customer loop=$custid&#125;id: &#123;$custid[customer]&#125;&lt;br&gt;&#123;sectionelse&#125;there are no values in $custid.&#123;/section&#125;","tags":[{"name":"smarty","slug":"smarty","permalink":"http://yuyouyou.github.io/tags/smarty/"}]},{"title":"前端冷知识(持续更新...)","date":"2016-02-18T02:44:36.000Z","path":"2016/02/18/third-article/","text":"浏览器地址栏运行JavaScript代码 1javascript:alert('hello from address bar :)'); 浏览器地址栏运行HTML代码 1data:text/html,&lt;h1&gt;Hello, world!&lt;/h1&gt; 把浏览器当编辑器 12地址栏输入：data:text/html, &lt;html contenteditable&gt;控制台输入：document.body.contentEditable='true'; 实时编辑CSS 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;style style=\"display:block\" contentEditable&gt; body &#123; color: blue &#125; &lt;/style&gt; &lt;/body&gt;&lt;/html&gt; 生成随机字符串 12345function generateRandomAlphaNum(len) &#123; var rdmString = \"\"; for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len);&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://yuyouyou.github.io/tags/前端/"}]},{"title":"hexo常用命令","date":"2016-02-10T07:42:45.000Z","path":"2016/02/10/second-article/","text":"hexo npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate –deploy hexo deploy –generate 模版 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub 设置文章摘要以上是文章摘要 以下是余下全文","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yuyouyou.github.io/tags/hexo/"}]},{"title":"GitHub+Hexo搭建个人博客","date":"2015-09-23T02:47:40.000Z","path":"2015/09/23/first-article/","text":"准备工作 安装Git 安装Node.js PS：傻瓜式的安装即可。。。 申请GitHub 进入GitHub官网注册帐号 注册完成后，点击”New repository”，新建一个版本库 输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 启用GitHub Page 1、点击“Setting”菜单进入设置,点击”Launch automatic page generator”,如下所示： 2、点击底部的”Continue to layouts”3、点击”Publish page”,发布github默认生成的一个静态站点4、最后可以看到成功后的界面，还可以自己修改主题： 安装Hexo 在电脑上新建一个blog文件夹,该文件夹用于存放博客文件,然后右键单击选择“Git Bash”，执行以下命令： 使用淘宝NPM镜像 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 使用淘宝NPM安装Hexo 1$ cnpm install -g hexo-cli 1$ cnpm install hexo --save 检查安装成功否1$ hexo -v 本地运行hexo 初始化hexo 1$ hexo init 安装生成器 1$ cnpm install 运行hexo（以后要在本地运行博客只要输入该命令即可） 1$ hexo s -g 打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了 配置blog 打开blog/_config.yml文件，进行配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#博客名称title: 我的博客#副标题subtitle: 副标题#简介description: 简介#博客作者author: 作者#博客语言language: zh-CN#时区timezone:#博客地址,与申请的GitHub一致url: http://yuyouyou.github.io#博客链接格式permalink: :year/:month/:day/:title/permalink_defaults:source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:default_category: uncategorizedcategory_map:tag_map:#日期格式date_format: YYYY-MM-DDtime_format: HH:mm:ss#分页，每页文章数量per_page: 10pagination_dir: page#博客主题theme: landscape#发布设置deploy: type: git #elfwalk改为你的github用户名 repository: https://github.com/yuyouyou/yuyouyou.github.io.git branch: master 创建一篇文章并用编辑器编辑 1$ hexo new \"hello\" 发布博客 设置git身份信息 12$ git config --global user.name \"你的用户名\"$ git config --global user.email \"你的邮箱\" 安装hexo git插件 1$ cnpm install hexo-deployer-git --save 发布更新博客 1$ hexo d -g 发布成功后，访问yourname.github.io看下成果吧","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yuyouyou.github.io/tags/hexo/"}]}]