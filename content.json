[{"title":"js实现浏览器通知功能","date":"2017-09-11T02:12:09.000Z","path":"2017/09/11/js-notification/","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近在做一个IM聊天系统，当新消息到来，需要在用户的桌面显示通知信息，在网上查阅才知道还有这个Notification API，下面介绍一下这个API。 &nbsp;&nbsp;&nbsp;&nbsp;首先我们需要检查浏览器是否支持这个API，可以直接用 window.Notification 来判断，如果为true就说明支持啦。。。光支持也不行，如果浏览器不允许弹出通知消息，那也是白搭的，所以，我们还要判断是否被准许—Notification.permission !== &quot;denied&quot; 来判断权限。 Notification.permission属性，用于读取用户给予的权限，它是一个只读属性，它有三种状态。default：用户还没有做出任何许可，因此不会弹出通知。granted：用户明确同意接收通知。denied：用户明确拒绝接收通知。 &nbsp;&nbsp;&nbsp;&nbsp;上面两个都为true后，就可以向用户弹出一条通知了。123456789if(window.Notification &amp;&amp; Notification.permission !== \"denied\") &#123; Notification.requestPermission(function(status) &#123; if (status === \"granted\") &#123; var n = new Notification('通知标题', &#123; body: '通知内容！' &#125;); &#125; else &#123; alert(\"通知内容！\"); &#125; &#125;);&#125; Notification构造函数的title属性是必须的，用来指定通知的标题，格式为字符串。options属性是可选的，格式为一个对象，用来设定各种设置。该对象的属性如下：dir：文字方向，可能的值为auto、ltr（从左到右）和rtl（从右到左），一般是继承浏览器的设置。lang：使用的语种，比如en-US、zh-CN。body：通知内容，格式为字符串。tag：通知的ID，格式为字符串。一组相同tag的通知，不会同时显示，只会在用户关闭前一个通知后，在原位置显示。icon：图表的URL，用来显示在通知上。 事件方法 show：通知显示给用户时触发。click：用户点击通知时触发。close：用户关闭通知时触发。error：通知出错时触发（大多数发生在通知无法正确显示时）。这些事件有对应的onshow、onclick、onclose、onerror方法，用来指定相应的回调函数。addEventListener方法也可以用来为这些事件指定回调函数。 举一个例子吧：12345var n = new Notification('通知标题', &#123; body: '通知内容！' &#125;);// 使其自动关闭n.onshow = function () &#123; setTimeout(n.close.bind(n), 5000);&#125;","tags":[{"name":"notification","slug":"notification","permalink":"http://yuyouyou.github.io/tags/notification/"}]},{"title":"水平和垂直居中(笔记)","date":"2017-07-23T02:55:07.000Z","path":"2017/07/23/css-align/","text":"一、水平居中 1、inline 元素用text-align: center;即可，如下：123.container &#123; text-align: center;&#125; 2、block 元素可使用margin: auto;1234567.container &#123; text-align: center;&#125;.item &#123; width: 1000px; margin: auto;&#125; 3、绝对定位元素可结合left和margin实现，但是必须知道宽度。1234567891011.container &#123; position: relative; width: 500px;&#125;.item &#123; width: 300px; height: 100px; position: absolute; left: 50%; margin: -150px;&#125; 二、垂直居中 1、inline 元素可设置line-height的值等于height值，如单行文字垂直居中：1234.container &#123; height: 50px; line-height: 50px;&#125; 2、绝对定位元素，可结合left和margin实现，但是必须知道尺寸。 优点：兼容性好 缺点：需要提前知道尺寸12345678910111213.container &#123; position: relative; height: 200px;&#125;.item &#123; width: 80px; height: 40px; position: absolute; left: 50%; top: 50%; margin-top: -20px; margin-left: -40px;&#125; 3、绝对定位可结合transform实现居中。 优点：不需要提前知道尺寸 缺点：兼容性不好12345678910111213.container &#123; position: relative; height: 200px;&#125;.item &#123; width: 80px; height: 40px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); background: blue;&#125; 4、绝对定位结合margin: auto，不需要提前知道尺寸，兼容性好。1234567891011121314.container &#123; position: relative; height: 300px;&#125;.item &#123; width: 100px; height: 50px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;&#125;","tags":[{"name":"布局","slug":"布局","permalink":"http://yuyouyou.github.io/tags/布局/"}]},{"title":"BFC和IFC(笔记)","date":"2017-07-23T02:12:24.000Z","path":"2017/07/23/BFC-IFC/","text":"一、BFC 什么是BFC？BFC的全称是Block Formatting Context，直译过来是：块级格式化上下文。 BFC的布局规矩： 1、内部box在垂直方向，一个接一个的放置;2、box的垂直方向由margin决定，属于同一个BFC的两个box间的margin会重叠3、BFC区域不会与float box重叠（可用于排版）；4、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。5、计算BFC的高度时，浮动元素也参与计算 哪些元素或属性会触发BFC呢？ 1、根元素；2、float属性不为none；3、position为absolute或fixed；4、display为inline-block, flex, 或者inline-flex；5、overflow不为visible； 二、IFC 同理，IFC是Inline formatting context。 在一个IFC中，从父级元素的顶部开始，盒子一个接一个横向排列。此时，横向的margin、borders、padding在这些盒子中都是有效的。这些盒子有可能通过不同的方式垂直对齐：1、他们底部或者顶部可以对齐，2、或者可以他们内部的文字基线可以对齐。如果一个矩形区域，包含着一些排成一条线的盒子，称为line box。 一个line box的宽度，由他的包含块(containg block)和floats的存在情况决定。linebox的高度，由你给出的代码决定。一般line box的高度对于子元素而言总是够用的，不过有可能比他包含的最高的元素还高（如果这样，内部包含的盒子会对齐，基线排成一排）。当盒子的高度小于父级盒子高度时，垂直方向的对齐由‘vertical-align’属性决定。当几个内联盒子在line box一行内放不下时，它们会分布在两个以上的垂直并列的line box上。 一般来说，line box和内部元素，都是左挨左，右挨右。不过浮动盒子可能会在包含块和line box的边缘之间。因此，即使line box在同一个IFC里通常有相同的宽度。如果他们横向间距会因float减少，它们宽度可能会不一样。line box在同一个IFC高度可能不一样。","tags":[{"name":"布局","slug":"布局","permalink":"http://yuyouyou.github.io/tags/布局/"}]},{"title":"Cookie、SessionStorage、LocalStorage的区别","date":"2017-07-17T13:33:56.000Z","path":"2017/07/17/cookie-localStorage/","text":"1、存储大小 cookie 数据大小不能超过4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 2、有效时间 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。 sessionStorage 数据在当前浏览器窗口关闭后自动删除。 3、数据与服务器之间的交互方式 cookie 数据始终在同源的http请求中携带，服务器端也可以写 cookie 到客户端。 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 4、作用域： cookies 和 localStorage是在所有同源窗口中共享的。 sessionStorage 不在不同的浏览器窗口共享，即使是同一个页面。","tags":[{"name":"本地存储","slug":"本地存储","permalink":"http://yuyouyou.github.io/tags/本地存储/"}]},{"title":"Cookie、Session的区别","date":"2017-07-16T13:00:02.000Z","path":"2017/07/16/cookie-session/","text":"1、存取方式的不同 Cookie中只能保管ASCII字符串，假如需要存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比较艰难的。 Session中能够存取任何类型的数据，包括不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类、对象等，运用起来十分便当。能够把Session看做是一个Java容器类。 2、隐私策略的不同 Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。 Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。 3、有效期上的不同 Cookie的过期时间可指定。 Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只要关闭了浏览器该Session就会失效，因而Session不能完成信息永久有效的效果。 4、服务器压力的不同 Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。 Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。 5、浏览器支持的不同 Cookie是需要客户端浏览器支持的。 假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。 6、跨域支持上的不同 Cookie支持跨域名访问，例如将domain属性设置为“baidu.com”，则以“baidu.com”为后缀的一切域名均能够访问该Cookie。 Session则不会支持跨域名访问。Session仅在它所在的域名内有效。","tags":[{"name":"本地存储","slug":"本地存储","permalink":"http://yuyouyou.github.io/tags/本地存储/"}]},{"title":"XSS攻击和防御","date":"2017-07-08T15:04:22.000Z","path":"2017/07/08/web-security1/","text":"&nbsp;&nbsp;&nbsp;&nbsp;XSS中文名称：跨站脚本攻击，就是通过向网站写入js脚本来实现攻击。攻击者在Web页面里插入恶意html代码，当用户浏览该网页时，嵌入其中代码会被执行，从而达到攻击用户的目的。 &nbsp;&nbsp;&nbsp;&nbsp;举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取到document.cookie然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。 &nbsp;&nbsp;&nbsp;&nbsp;攻击过程： &nbsp;&nbsp;&nbsp;&nbsp;其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。 &nbsp;&nbsp;&nbsp;&nbsp;防御方法： 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有：123456&amp; 替换为：&amp;amp;&lt; 替换为：&amp;lt;&gt; 替换为：&amp;gt;” 替换为：&amp;quot;‘ 替换为：&amp;#x27;/ 替换为：&amp;#x2f; 替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。 除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加http-only限制，让 JS 获取不到 cookie 的内容。","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yuyouyou.github.io/tags/web安全/"}]},{"title":"CSRF攻击和防御","date":"2017-07-08T14:12:03.000Z","path":"2017/07/08/web-security/","text":"&nbsp;&nbsp;&nbsp;&nbsp;CSRF中文名称：跨站请求伪造，攻击者盗用客户的身份，以客户名义发送恶意请求。 &nbsp;&nbsp;&nbsp;&nbsp;攻击者借用你的权限，以你的名义发送恶意请求，并没有拿到你的用户信息，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。 &nbsp;&nbsp;&nbsp;&nbsp;攻击过程： 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个标签页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 &nbsp;&nbsp;&nbsp;&nbsp;例如，一个支付类网站，给他人转账的接口是http://buy.com/pay?touid=999&amp;money=100，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了http://buy.com，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码&lt;img src=&quot;http://buy.com/pay?touid=999&amp;money=100&quot;/&gt;，他访问了邮件之后，其实就已经完成了购买。 &nbsp;&nbsp;&nbsp;&nbsp;防御方法： （1）验证 HTTP Referer 字段&nbsp;&nbsp;&nbsp;&nbsp;根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 （2）在请求地址中添加 token 并验证&nbsp;&nbsp;&nbsp;&nbsp;CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 （3）在 HTTP 头中自定义属性并验证&nbsp;&nbsp;&nbsp;&nbsp;这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yuyouyou.github.io/tags/web安全/"}]},{"title":"使用 node-inspector 调试 Node.js","date":"2017-06-25T13:31:04.000Z","path":"2017/06/25/node-inspector/","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近在看书籍《Node.js开发指南》，看到一个调试工具还不错，简单介绍一下：node-inspector。 &nbsp;&nbsp;&nbsp;&nbsp;node-inspector 是一个完全基于 Node.js 的开源在线调试工具，提供了强大的调试功能和友好的用户界面，它的使用方法十分简便。&nbsp;&nbsp;&nbsp;&nbsp;首先，使用 npm install -g node-inspector 命令安装 node-inspector，然后在终端中通过 node --debug-brk=5858 debug.js 命令连接你要除错的脚本的调试服务器，启动 node-inspector: &nbsp;&nbsp;&nbsp;&nbsp;$ node-inspector &nbsp;&nbsp;&nbsp;&nbsp;在浏览器中打开 http://127.0.0.1:8080/debug?port=5858 ,即可显示出优雅的 Web 调试工具： &nbsp;&nbsp;&nbsp;&nbsp;node-inspector 的使用方法十分简单，和浏览器调试工具一样的，支持单步、断点、 调用栈查看等功能。无论你以前有没有使用过调试工具，都可以在几分钟内轻松掌握。","tags":[{"name":"node调试工具","slug":"node调试工具","permalink":"http://yuyouyou.github.io/tags/node调试工具/"}]},{"title":"一行命令轻松完成Node.js版本升级","date":"2017-06-25T02:02:21.000Z","path":"2017/06/25/node-update/","text":"&nbsp;&nbsp;&nbsp;&nbsp;Node.js的开发非常活跃，它的最新稳定版本也频繁变化，时不时会发现，一个模块不能在你当前的Node版本上使用，此时就需要升级Node，而且有的项目运行也对Node版本要求不一样，可能会需要频繁的切换版本，所以呢，下面介绍一种非常简单的方法来管理你的Node版本，即使用Node Binary管理模块“n”。第一步：安装n模块 npm install -g n 第二步：切换指定Node版本 n v6.9.4 或 n 6.9.4 就这么简单，是不是超级轻松呢？！ 而且，如果你想直接升级Node到最新稳定版，执行一下 n stable 就搞定了！！！","tags":[{"name":"node","slug":"node","permalink":"http://yuyouyou.github.io/tags/node/"}]},{"title":"jsonp 请求，捕获异常处理","date":"2017-06-12T15:31:44.000Z","path":"2017/06/12/ajax-jsonp/","text":"问题：&nbsp;&nbsp;&nbsp;&nbsp;ajax 用 jsonp 方式时，当请求的url为404或者50X时，不会执行 error 的回调事件。 原因：&nbsp;&nbsp;&nbsp;&nbsp;当资源404，或者报错的时候，也就是返回不成功的时候， jsonp 是无法得到状态，不会进 success，也不会进 error 方法。有人会说 script 的话，有 onerror 方法，但是这个方法有浏览器兼容问题。解决办法：&nbsp;&nbsp;&nbsp;&nbsp;采用 timeout 属性，因为资源只要没有正确返回，就会计算在 timeout 时间消耗内。 12345678$.ajax(&#123; url:\"\", timeout:4000, // 超过4秒没正确返回，就会进入 error dataType:\"jsonp\", error:function (e) &#123; // todo &#125;&#125;);","tags":[{"name":"ajax","slug":"ajax","permalink":"http://yuyouyou.github.io/tags/ajax/"},{"name":"jsonp","slug":"jsonp","permalink":"http://yuyouyou.github.io/tags/jsonp/"}]},{"title":"Ajax请求成功后使用window.open()新开窗口被拦截","date":"2017-06-12T15:01:34.000Z","path":"2017/06/12/ajax-window-open/","text":"&nbsp;&nbsp;&nbsp;&nbsp;我最近做一个下载文件需求时，使用 ajax 异步请求成功后新开窗口打开下载url，使用的是 window.open() 方法，发现浏览器会拦截，在网上找了很久的原因才知道：因为该操作并不是用户主动触发的，所以浏览器认为这是不安全的就拦截了，即使 ajax 回调函数中模拟执行 click 或者 submit 等用户行为（trigger(‘click’)），浏览器也会认为不是由用户主动触发的，因此不能被安全执行，所以被拦截。 &nbsp;&nbsp;&nbsp;&nbsp;在网上找了很多解决办法，以下两个是最有效的，解决了我的问题： 1、异步改为同步&nbsp;&nbsp;&nbsp;&nbsp;即：async: false，把 window.open() 写在 ajax 函数外面，比如：定义一个flag，请求成功的时候赋值true，失败赋值false，当flag为true时调用 window.open() ，总之就是要把 window.open() 放在ajax外面执行。 2、将新开窗口指向为一个对象，然后修改对象的 url 1234567891011121314$('.test').bind('click',function()&#123; var w = window.open(); $.ajax(&#123; type: 'post', url: '/test', dataType: 'json', error: function()&#123; w.close(); &#125;, success: function(res)&#123; w.location = res.url; &#125; &#125;);&#125;);","tags":[{"name":"ajax","slug":"ajax","permalink":"http://yuyouyou.github.io/tags/ajax/"},{"name":"window","slug":"window","permalink":"http://yuyouyou.github.io/tags/window/"}]},{"title":"回顾JavaScript基础知识 — 闭包和垃圾回收机制","date":"2017-05-31T13:02:41.000Z","path":"2017/05/31/review-js4/","text":"&nbsp;&nbsp;&nbsp;&nbsp;闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量，比如函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。文字上不好理解，就看下面的示例：123456789function F1()&#123; var a=\"函数1的内部变量\"; return function()&#123; console.log(a); &#125;&#125;var f = F1();var a = \"全局变量\"f();// 函数1的内部变量 &nbsp;&nbsp;&nbsp;&nbsp;这样就创建了一个简单的闭包，返回的新函数还可以访问变量a，是因为新函数中的作用域链还包括F1的作用域。因此内存中仍存在这个活动对象，一旦返回的新函数被销毁，这个活动对象也会被销毁。&nbsp;&nbsp;&nbsp;&nbsp;那么我们为什么需要闭包呢？使用闭包主要是设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。这里就要垃圾回收机制登场了(简单介绍)。 &nbsp;&nbsp;&nbsp;&nbsp;垃圾回收机制，也就是执行环境会负责管理代码执行过程中使用的内存，在开发过程中就无需考虑内存分配及无用内存的回收问题了。JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。主要有如下2种： 1、标记清除（mark and sweep） &nbsp;&nbsp;&nbsp;&nbsp;这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。至于怎么标记有很多种方式，比如特殊位的反转、维护一个列表等，这些并不重要，重要的是使用什么策略，原则上讲不能够释放进入环境的变量所占的内存，它们随时可能会被调用的到。&nbsp;&nbsp;&nbsp;&nbsp;垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，然后垃圾回收器相会这些带有标记的变量机器所占空间。 2、引用计数(reference counting) &nbsp;&nbsp;&nbsp;&nbsp;在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuyouyou.github.io/tags/JavaScript/"}]},{"title":"回顾JavaScript基础知识 — 变量提升","date":"2017-05-30T13:56:17.000Z","path":"2017/05/30/review-js3/","text":"&nbsp;&nbsp;&nbsp;&nbsp;JavaScript 中，函数声明和变量声明总是会被解释器悄悄地”提升”到方法体的最顶部。&nbsp;&nbsp;&nbsp;&nbsp;JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。 &nbsp;&nbsp;&nbsp;&nbsp;通过一个简单的代码示例解释一下12345678910111213console.log(a) // undefinedvar a = 100fn('zhangsan') // 'zhangsan' 20function fn(name) &#123; age = 20 console.log(name, age) var age&#125;console.log(b); // 这里报错// Uncaught ReferenceError: b is not definedb = 100; &nbsp;&nbsp;&nbsp;&nbsp;在一段 JS 脚本（即一个&lt;script&gt;标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 全局执行上下文 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。 &nbsp;&nbsp;&nbsp;&nbsp;我们来看下上面的结果，为什么a是undefined，而b却报错了，实际 JS 在代码执行之前，要「全文解析」，发现var a，知道有个a的变量，存入了执行上下文，而b没有找到var关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的a是有记录的，只不过值暂时还没有赋值，即为undefined，而b在执行上下文没有找到，自然会报错（没有找到b的引用）。 &nbsp;&nbsp;&nbsp;&nbsp;另外，一个函数在执行之前，也会创建一个 函数执行上下文 环境，跟 全局上下文 差不多，不过 函数执行上下文 中会多出this arguments和函数的参数。 &nbsp;&nbsp;&nbsp;&nbsp;要注意的是： 只有声明的变量会提升，初始化的值不会，比如 a是undefined，而不是10，因为var a 提升了，但是值还在原处。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuyouyou.github.io/tags/JavaScript/"}]},{"title":"回顾JavaScript基础知识 — 原型和原型链","date":"2017-05-29T14:11:00.000Z","path":"2017/05/29/review-js2/","text":"原型 可以从下面这几个要点来理解，下面几条必须记住并且理解。 1、所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外）2、所有的引用类型（数组、对象、函数），都有一个__proto__属性，属性值是一个普通的对象3、所有的引用类型（数组、对象、函数），__proto__属性值指向它的构造函数的prototype属性值4、所有的函数，都有一个prototype属性，属性值也是一个普通的对象通过代码解释一下12345678910111213141516// 自由扩展属性var obj = &#123;&#125;; obj.a = 100;var arr = []; arr.a = 100;function fn () &#123;&#125;fn.a = 100;// __proto__console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__);// 引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值console.log(obj.__proto__ === Object.prototype)// 函数有 prototypeconsole.log(fn.prototype) 接下来看一个简单的代码示例：123456789101112131415// 构造函数function Foo(name, age) &#123; this.name = name&#125;Foo.prototype.alertName = function () &#123; alert(this.name)&#125;// 创建示例var f = new Foo('yushuang')f.printName = function () &#123; alert(this.name)&#125;// 测试f.printName() // yushuangf.alertName() // yushuang 执行printName时很好理解，但是执行alertName时为什么是这个结果呢？这里再记住一个重点：当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找，因此f.alertName就会找到Foo.prototype.alertName。 原型链 还是接着上面的示例，如果执行f.toString()，又会发生什么？为什么是这个结果呢？1f.toString() // [object Object] 因为f本身没有toString()，并且f.__proto__（即Foo.prototype）中也没有toString。这个问题还是得拿出刚才那句话——当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找。 如果在f.__proto__中没有找到toString，那么就继续去f.__proto__.__proto__中寻找，因为f.__proto__就是一个普通的对象而已！ &nbsp;&nbsp;&nbsp;&nbsp;》f.__proto__即Foo.prototype，没有找到toString，继续往上找&nbsp;&nbsp;&nbsp;&nbsp;》f.__proto__.__proto__即Foo.prototype.__proto__。Foo.prototype就是一个普通的对象，因此Foo.prototype.__proto__就是Object.prototype，在这里可以找到toString&nbsp;&nbsp;&nbsp;&nbsp;》因此f.toString最终对应到了Object.prototype.toString 这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是什么 —— Object.prototype.__proto__ === null","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuyouyou.github.io/tags/JavaScript/"}]},{"title":"回顾JavaScript基础知识 — 变量类型","date":"2017-05-28T14:30:23.000Z","path":"2017/05/28/review-js1/","text":"&nbsp;&nbsp;&nbsp;&nbsp;JavaScript是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。 原始类型 &nbsp;&nbsp;&nbsp;&nbsp;ECMAScript中定义了 6 种原始类型，分别是Boolean、String、Number、Null 、Undefined、Symbol。 值类型 vs 引用类型 &nbsp;&nbsp;&nbsp;&nbsp;根据JavaScript中的变量类型传递方式，又分为值类型和引用类型，值类型变量包括 Boolean、String、Number、Undefined、Null，引用类型包括了Object类的所有，如 Date、Array、Function等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。 &nbsp;&nbsp;&nbsp;&nbsp;下面通过一个小题目，来看下两者的主要区别，以及实际开发中需要注意的地方。123456// 值类型var a = 10var b = ab = 20console.log(a) // 10console.log(b) // 20 &nbsp;&nbsp;&nbsp;&nbsp;上述代码中，a b都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：1234567// 引用类型var a = &#123;x: 10, y: 20&#125;var b = ab.x = 100b.y = 200console.log(a) // &#123;x: 100, y: 200&#125;console.log(b) // &#123;x: 100, y: 200&#125; &nbsp;&nbsp;&nbsp;&nbsp;上述代码中，a b都是引用类型。在执行了b = a之后，修改b的属性值，a的也跟着变化。因为a和b都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此b修改属性时，a的值随之改动。&nbsp;&nbsp;&nbsp;&nbsp;JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。&nbsp;&nbsp;&nbsp;&nbsp;引用类型经常会在代码中按照下面的写法使用，或者说容易不知不觉中造成错误！123456789var obj = &#123; a: 1, b: [1,2,3]&#125;var a = obj.avar b = obj.ba = 2b.push(4)console.log(obj, a, b) &nbsp;&nbsp;&nbsp;&nbsp;虽然obj本身是个引用类型的变量（对象），但是内部的a和b一个是值类型一个是引用类型，a的赋值不会改变obj.a，但是b的操作却会反映到obj对象上。 判断类型 1、typeof &nbsp;&nbsp;&nbsp;&nbsp;typeof返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。typeof可以对基本类型number、string 、boolean、undefined做出准确的判断（null除外，typeof null===“object”)；而对于引用类型，除了function之外返回的都是object。但当我们需要知道某个对象的具体类型时，typeof就显得有些力不从心了。123456789typeof 1; // number 有效typeof ‘ ’;//string 有效typeof true; //boolean 有效typeof undefined; //undefined 有效typeof null; //object 无效typeof new Function(); // function 有效typeof [] ; //object 无效typeof new Date(); //object 无效typeof new RegExp(); //object 无效 2、instanceof &nbsp;&nbsp;&nbsp;&nbsp;instanceof用于实例和构造函数的对应，当我们需要知道某个对象的具体类型时,可以用运算符 instanceof，instanceof操作符判断左操作数对象的原型链上是否有右边这个构造函数的prototype属性，最后返回布尔值。 注意的是:instanceof运算符只能用于对象，不适用原始类型的值。123'hello' instanceof String // falsenull instanceof Object // falseundefined instanceof Object // false 3、Object.prototype.toString &nbsp;&nbsp;&nbsp;&nbsp;toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object,xxx],xxx是具体的数据类型，其中包括：String,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error… 基本上所有对象的类型都可以通过这个方法获取到。12345678910Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error] &nbsp;&nbsp;&nbsp;&nbsp;为什么要用call()来获取呢？因为从原型链的角度讲，所有对象的原型链最终都指向了Object, 按照JS变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用call来强制执行Object的toString方法。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuyouyou.github.io/tags/JavaScript/"}]},{"title":"如何从细节上提升用户体验","date":"2017-04-20T02:11:08.000Z","path":"2017/04/20/frond-UE/","text":"&nbsp;&nbsp;&nbsp;&nbsp;在这个互联网时代，用户成为主要的生产者，如果你的网站看上去就像个钓鱼网站而且还特别难用，就会有一部分用户离你而去。就算你花了很大的功夫优化数据库，优化服务器负载，你的客户却很难感知到你的努力。或者你的系统界面还是八九十年代的风格，用户的第一感觉就是这系统不行，不买你的帐。相反，如果你花一点时间做一套崭新风格的界面出来，用户的第一感觉就是这个系统好炫酷，技术术含量很高。所以要想留住用户，我们必须重视用户体验，从细节上来提升用户体验，说了这么多，前端终究是一个程序员，和用户体验的关系又是怎样的呢？&nbsp;&nbsp;&nbsp;&nbsp;前端跟用户的距离其实很近，对于用户体验的提升不仅是产品经理、设计师应该思考的，前端也有很大的关联。首先、前端是用户体验的把控者。在产品经理构想出交互原型，设计师设计出交互细节后，前端就要用双手一行行敲出这些代码。我们敲出的每一个按钮，每一张图片，都被成千上万的用户点击着，我们与用户可以说是“零距离接触”。其次，我们需要对用户体验有较深的理解。比如页面上有一个超链接，字体比较小的情况下，用户可能会一下点不中，因为链接的可点击区域是紧贴着文字边缘的。我们就可以通过很简单的方法来扩大这个链接的可点击区域，使得用户更容易点中。再比如采用技术手段让页面的滚动更平滑些，减少页面的视觉抖动，像素级别的定位校准等等，很多细节是产品经理无法感知的，因为这些都是很零散的技术手段，只有靠前端来点滴积累。再有极致者，追求让页面的响应时间再减少几个毫秒，让你的手机少耗几KB流量，少耗一些电量。这些甚至连用户都无法感知，但是当你的用户有百万级别或者千万级别，这样做的价值就显现出来了。总而言之，无论是友好的视觉配色、友好的询问时机及语句，还是舒服而优雅的转换，前端可以做的事情都很多，下面主要列举了十点来进行说明： 一、整体颜色一致性&nbsp;&nbsp;&nbsp;&nbsp;从进入一个网站后，就要有一个主色调的确定。在色调的选择上也是十分有讲究的。电商网站颜色选择上，多为红色（橘色）。红色主要能引起人的购买欲望。黑色也是电商的主要选择，那是因为黑色具有高贵神秘感，多为奢侈品电商使用的主色调。比如蓝色具有自由感觉，适合旅游网站。又比如绿色更多都是社交IM产品使用。虽然颜色上会有出入，但总体的设计理念不会改变。当进入一个网站后，整体色调要给人一种过渡和谐的感觉。所以这是我们所要说的颜色一致性。这种整体颜色感官体验大大增加用户的好感度。 二、全部结构整洁性&nbsp;&nbsp;&nbsp;&nbsp;要在结构上保持视觉上的整洁性。往往我们在浏览一个网站的时候，都会觉得电商或者O2O的首页整洁性比较差。因为业务承载量太大，所以无法保持绝对意义上的整洁。整洁度并不是在一定程度上保持过分的简单，过分的简单可以保持整洁度，但不能承载业务。所以在产品设计上，整洁度一定是在允许合理范围之内的。比如：微信的发现功能页面。它将朋友圈为一列，将扫一扫和摇一摇作为一列，附近的人和漂流瓶作为一列，购物和游戏作为一列。这是在展示上有一定整洁性，帮助用户快速找到想要的功能。假设这里只是单纯的list页面排序下来，没有这样的区别，那用户的感受会十分糟糕。所以结构整洁性是为了保证用户操作的便利性。 三、首页展示内容完整性&nbsp;&nbsp;&nbsp;&nbsp;保证了整洁性，才能保证展示首页的内容完整性。作为首页，你最需要展示给用户的是你最优质的内容（服务或商品）业务。而这个内容是你用户最大的痛点需求，这个痛点需求能牢牢地抓住用户心理。即可以达到2秒时间便可以留下来使用这个平台。虽然增加的用户路径，但保证了用户在首屏便能快速了解整体所有业务。而音乐类产品会把最主要的播放器的放在底部，一个是为了功能的快速播放，另一点也是内容完整性展示，如果将播放器移除首页，后果也不堪设想。包括新闻类产品将所有的分类置于顶部，也是一种业务层面上的展示完整性的选择。首页内容展示完整性，保证了所有业务能最快速的触达用户内心。用户便留下了你平台所能起到什么作用的第一印象。 四、Logo&nbsp;&nbsp;&nbsp;&nbsp;当我们第一眼看到一个logo的时候，我们首先识别的是它的颜色，形状和形式，而不会直接把不同的部分当作一个整体来识别。然后，我们的大脑再把我们看到的这些视觉图案和我们脑袋里既有的经验做匹配，以此来解释我们看到这个图案，最后我们才能理解一个logo的含义。所以，我们在设计logo的时候，就需要向用户传达更多的意思，而不仅仅用于区分不同的企业。从用户体验的角度来看，logo也是网站的一个最重要的识别符号，把logo始终放在一个固定的位置，一定程度上提升了用户体验。同时logo也是用户定位自己位置的一种方式，通常来说，它是回到网站首页的一种快捷方式。在尼尔森诺曼集团的一项研究中，参与者被要求完成一个导航任务，结果显示，当logo放在左边的时候，用户体验更好，当想要返回首页的时候，logo放在中间相较于logo放在左上角，操作起来要困难6倍，因为人最习惯第一眼浏览的网页位置，就是左上角。 五、错误状态&nbsp;&nbsp;&nbsp;&nbsp;“错误”时有发生。有时是因为平台出现BUG，有时是系统错误。无论错误原因是什么，解决方式都对用户体验影响深远。但它往往不被重视，草草处理错误、组织混乱的错误信息会使用户沮丧，最终抛弃你的产品。相反，处理得当的错误提示，能把失败变为惊喜。比如： 用户输入错误&nbsp;&nbsp;&nbsp;&nbsp;用户输入信息验证的意义在于与用户交流，并引导他们克服困难，应对不确定。输入验证的首要原则是：“出现错误时告知他们，让他们避免困惑！”简单说，优秀的表单验证由3个重要元素组成：在适当时机和位置告知错误、为错误信息选择合适的颜色、用简明的语言描述错误。（1）适当的时机和位置(行内验证)&nbsp;&nbsp;&nbsp;&nbsp;用户并不喜欢填完一个长表单并提交之后，才发现哪里填错了。告知输入信息正确与否的恰当时机，正是在输入之后。实时验证就该出场了。实时行内验证会立刻对用户输入作出提醒。如果使用行内表单验证，就会清晰标明有错误的输入项，发生错误时，提交按钮也会置灰。用户不必等到点击提交按钮才看到错误，他们能更早改正错误。（2）合适的颜色(直观的设计)&nbsp;&nbsp;&nbsp;&nbsp;颜色是设计验证信息的最佳手段。因为它能引发本能作用，红色的错误信息和黄色的警告信息非常有效。错误文字应当易于阅读，与背景有足够的反差，让人能注意到。（3）简明的信息(发生了什么)&nbsp;&nbsp;&nbsp;&nbsp;确保错误信息是写给人看的。要实现这一点，就得用用户的语言来说话，避免使用技术术语，用用户的词汇来表达一切。验证信息要清晰陈述以下内容：什么出错了，为什么。用户接下来该做什么来解决错误。&nbsp;&nbsp;&nbsp;&nbsp;典型的错误会直接说“信息不正确”，没有告诉用户它为什么错了（是数据类型错误？还是已经被占用了？）。确保信息清晰明确。 产品的错误&nbsp;&nbsp;&nbsp;&nbsp;产品也会发生错误，它不受用户输入影响。这种情况下，用户会遭遇意料之外的状态。显示错误时，要解释一下用户为什么一无所获，如何摆脱当前处境。比如：（1）同步错误/加载错误&nbsp;&nbsp;&nbsp;&nbsp;当同步或链接断开，或者内容加载失败时，应该告知用户。要预先告诉他们。由于没有数据，可以使用空状态填补空隙。可悲事实是，许多空状态看起来……真的是空的。下面的例子中，错误界面只说“发生了错误”，没有提供一点有用的信息。这个空状态界面就是个死胡同。应该把错误提示想象成与用户的一场对话。在遭遇失败时，用友好且有意义的空状态来沟通。提供基本所需的信息来帮助用户，鼓励他们解决问题。这是一个正确的示范：走丢了，失去连接，就像置身于荒岛？可以跟随建议，保持冷静，点起篝火，持续刷新。所以，在适当时机，提供链接或按钮帮助用户完成任务。但要提供你所能做到的操作。如果明知道会失败，就不要放出“再试一次”这样的选项。（2）不要展示原始错误信息&nbsp;&nbsp;&nbsp;&nbsp;这种错误信息，是由开发者写给另一名开发者看的。不要假设人们知道提示信息的来龙去脉，或者指望他们是技术专家，要用简单的语言告诉人们哪里出错了。如何用人话来解释这些错误？把它写下来，那就是你的错误提示文案。&nbsp;&nbsp;&nbsp;&nbsp;从不出现的错误信息才是最好的。最佳方式是引导用户向正确方向前进，第一时间预防错误发生。但当错误确实发生时，设计精良的错误处理，不仅能教育用户按你预期的方式使用产品，还能防止用户感到茫然。 六、文字排版&nbsp;&nbsp;&nbsp;&nbsp;当谈到字体排版的时候，不同的字体和排版会给我们带来不同感受，或好或不好，这些感受来自于字体不同的大小、一句话的长度、或者合适的间隙等等。在一个网站中，字体通常是承载内容的主体，因此，字体排版对用户体验有着重要的影响，决定着线上的阅读体验。我们应该：1、选择合适的字体。用于网上阅读的大段文字的字体要避免使用手写体和装饰较多的字体，这些字体难以识别，这会严重降低人们的阅读速度。研究表明应该使用简单的非衬线体字体。2、选择合适的字号。最小字号不要低于12pt。3、每一行的文字数量要合适。一行字太短，人的实视线需要频繁的左右移动来寻找开始和结束的位置。若一行字太长，人们又很难找到下一行开始的地方。一行字的长短最合适的范围是50~75个英文字符，对应于中文字符，差不多是27~40字之间。4、合适的间隙。确保行间距足够宽，行间距是影响用户阅读体验的关键因素之一，太过致密会令人阅读困难，有呼吸感的行间距则会令人着迷。尤其是如今大量用户在手机和平板上阅读，相对宽一点的行间距对于缓解阅读大量内容有相当的缓解作用。宽松的行间距（比如直接空一行作为行间距）能让内容更易于被识别和扫描。5、克制地使用字体。最好只用两种字体。控制字体类型的数量应该是每一个项目的目标。太多用户喜欢在一个界面当中疯狂地塞进各种不同类型的字体，这对于眼睛是灾难性的，阅读困难，甚至招致用户厌倦。你可以挑选两个字体族作为常用字体——最多再挑选一款艺术字体用作展示之用——然后坚持使用这几种字体。想清楚每个字体在什么时候使用，在什么地方使用，这其中应当涉及到字体的颜色、大小和位置。另外，在不同的页面、不同设备上，字体的使用应该是一致的。 七、文案&nbsp;&nbsp;&nbsp;&nbsp;“文案”这个词看起来好像很简单，且主观感觉优先级略低，但并不意味着它容易表述。一个好的文案说明是需要从多个角度出发考虑的，表述不清晰就会对用户造成误导。我们应该让产品像人一样和你的用户交谈，而不是从机器人的角度出发去思考文案内容。同时文案要言简意赅，思考关于用户对这个操作行为的目的是什么，然后通过文案说明，使用简单明确的文字来说明你需要表达的意思。用户不喜欢长文本，必须确保你的文案是简短且能明确传达意思的。总之，让用户感觉到我们平台有温度，而不是冷冰冰的。 八、按钮交互严谨性&nbsp;&nbsp;&nbsp;&nbsp;按钮是交互中最为常见的组件。包括底部导航上，确认或取消按钮，返回按钮等等。严谨性不仅包括逻辑上的正确，也包括了用户文案简单理解的程度。在电商购买页面中，我们会把购买按钮作为吸底式放在底部。一般左边是加入购物车右边是立即购买，因为这里有逻辑上严谨性，右边更为重要，还有也是用户操作习惯上的严谨性，右边多为更关键的操作。而客服，店铺，收藏等辅助按钮需要弱化，因为它对主购买流程不构成影响，这里这样做的原因还有需要去除用户过多的思考。按钮严谨性不言而喻，因为每一步流转，都是一次用户流失的过程。为了避免用户在按钮点击过程中流失，我们更需要关注按钮的严谨性。那么一个好的引导按钮有哪些特征呢？1、有足够的视觉吸引力，使得用户很想要去点击。2、按钮上的文案要简洁，字数不能太多，不要超过5个字。3、文字需要是引导性的动词，比如下载、注册、开始等等。4、使用高对比的颜色，但又要能和谐融入整个设计风格中。5、按钮要足够大，要从较远的距离上都能看见，但又不能大到让用户从主要内容上分心。6、操作结果要可预期，让用户能明白点击后会发生什么。 九、输入框便利性&nbsp;&nbsp;&nbsp;&nbsp;登录的时候我们有输入框，聊天的时候有输入框，购买商品或服务的时候，支付填写信息的时候。输入框是除了按钮之外最多的组件。输入框的便利性是让用户使用下去的保证，在输入时绝对不能让用户出现有挫败感的心理。比如很多的输入框，登录名加上一条横线，当手指触碰点击登录名时候，并未点击到横线上时，居然没有弹出键盘，用户第一反应肯定是卡机了，第二反应是产生强烈的挫败感。在这种细节把握上，一定不能让用户出现挫败感心里。在登录的时候，输入用户名字的时候，弹出的是英文键盘。输入手机号的时候，弹出的是数字键盘。这些细小的差别，都是用户在输入时的便利性的体现。输入框不仅是技术上的数据交互和抓取，产品设计上的漂亮，更要关注让用户使用下去的动力。 十、图形&nbsp;&nbsp;&nbsp;&nbsp;在谈论视觉设计的时候，难以忽视的一个重要视觉元素就是：图像。我们的大脑在处理图像信息的时候，速度是很惊人的，只需要13毫秒。这极快的处理速度能帮助我们更快的获取到信息。例如，当我们在看一个卖鞋的网页时，看到一双鞋子的图片，我们能马上知道是什么类别，我们是否喜欢，如果喜欢，我们下一步才是去看价格。使用图片也能显著增加一个网站的用户转化率，可以想象一下，有多少人会在一个不提供商品图片的网站上购买商品。同时，配了图的文章比没配图的文章，阅读量要多94%。 一张好的图片展示，是很能影响用户的体验的。 &nbsp;&nbsp;&nbsp;&nbsp;最后，我想说用户体验是一种过程，而不是结果，既然是为了提升用户体验 ，就得与用户一起进行体验的沟通交流，才能有根据的进行优化。用户的沟通交流是其中的关键，在用户的帮助下，你很容易找到可提升的体验点。同时体验始终在不断变化，无论是设计师还是技术，都要持续的自我增值，才能跟上产品迭代、时代发展的步伐，这样才能把产品优化的越来越好，而不是仅仅停留在“这个产品我做完了”的想法上。 参考链接：http://www.woshipm.com/ucd/279091.htmlhttps://uxplanet.org/mobile-ux-design-user-errors-1ad1f5d664f9","tags":[{"name":"用户体验","slug":"用户体验","permalink":"http://yuyouyou.github.io/tags/用户体验/"}]},{"title":"JavaScript风格指南","date":"2017-03-17T02:25:09.000Z","path":"2017/03/17/js-style/","text":"作者根据Robert C. Martin《代码整洁之道》总结了适用于JavaScript的软件工程原则《Clean Code JavaScript》。本文是对其的翻译。不必严格遵守本文的所有原则，有时少遵守一些效果可能会更好，具体应根据实际情况决定。这是根据《代码整洁之道》作者多年经验整理的代码优化建议，但也仅仅只是一份建议。软件工程已经发展了50多年，至今仍在不断前进。现在，把这些原则当作试金石，尝试将他们作为团队代码质量考核的标准之一吧。最后你需要知道的是，这些东西不会让你立刻变成一个优秀的工程师，长期奉行他们也并不意味着你能够高枕无忧不再犯错。千里之行，始于足下。我们需要时常和同行们进行代码评审，不断优化自己的代码。不要惧怕改善代码质量所需付出的努力，加油。 目录 变量 函数 对象和数据结构 类 测试 并发 错误处理 格式化 注释 变量使用有意义，可读性好的变量名反例:1var yyyymmdstr = moment().format('YYYY/MM/DD'); 正例:1var yearMonthDay = moment().format('YYYY/MM/DD'); 回到目录 使用ES6的const定义常量反例中使用”var”定义的”常量”是可变的。 在声明一个常量时，该常量在整个程序中都应该是不可变的。 反例:1var FIRST_US_PRESIDENT = \"George Washington\"; 正例:1const FIRST_US_PRESIDENT = \"George Washington\"; 回到目录 对功能类似的变量名采用统一的命名风格反例:123getUserInfo();getClientData();getCustomerRecord(); 正例:1getUser(); 回到目录 使用易于检索名称我们需要阅读的代码远比自己写的要多，使代码拥有良好的可读性且易于检索非常重要。阅读变量名晦涩难懂的代码对读者来说是一种相当糟糕的体验。让你的变量名易于检索。 反例:1234// 525600 是什么?for (var i = 0; i &lt; 525600; i++) &#123; runCronJob();&#125; 正例:12345// Declare them as capitalized `var` globals.var MINUTES_IN_A_YEAR = 525600;for (var i = 0; i &lt; MINUTES_IN_A_YEAR; i++) &#123; runCronJob();&#125; 回到目录 使用说明变量(即有意义的变量名)反例:12const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d&#123;5&#125;)?$/;saveCityState(cityStateRegex.match(cityStateRegex)[1], cityStateRegex.match(cityStateRegex)[2]); 正例:12345const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d&#123;5&#125;)?$/;const match = cityStateRegex.match(cityStateRegex)const city = match[1];const state = match[2];saveCityState(city, state); 回到目录 不要绕太多的弯子显式优于隐式。 反例:12345678910var locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((l) =&gt; &#123; doStuff(); doSomeOtherStuff(); ... ... ... // l是什么？ dispatch(l);&#125;); 正例:123456789var locations = ['Austin', 'New York', 'San Francisco'];locations.forEach((location) =&gt; &#123; doStuff(); doSomeOtherStuff(); ... ... ... dispatch(location);&#125;); 回到目录 避免重复的描述当类/对象名已经有意义时，对其变量进行命名不需要再次重复。 反例:123456789var Car = &#123; carMake: 'Honda', carModel: 'Accord', carColor: 'Blue'&#125;;function paintCar(car) &#123; car.carColor = 'Red';&#125; 正例:123456789var Car = &#123; make: 'Honda', model: 'Accord', color: 'Blue'&#125;;function paintCar(car) &#123; car.color = 'Red';&#125; 回到目录 避免无意义的条件判断反例:12345678function createMicrobrewery(name) &#123; var breweryName; if (name) &#123; breweryName = name; &#125; else &#123; breweryName = 'Hipster Brew Co.'; &#125;&#125; 正例:123function createMicrobrewery(name) &#123; var breweryName = name || 'Hipster Brew Co.'&#125; 回到目录 函数函数参数 (理想情况下应不超过2个)限制函数参数数量很有必要，这么做使得在测试函数时更加轻松。过多的参数将导致难以采用有效的测试用例对函数的各个参数进行测试。 应避免三个以上参数的函数。通常情况下，参数超过两个意味着函数功能过于复杂，这时需要重新优化你的函数。当确实需要多个参数时，大多情况下可以考虑这些参数封装成一个对象。 JS定义对象非常方便，当需要多个参数时，可以使用一个对象进行替代。 反例:123function createMenu(title, body, buttonText, cancellable) &#123; ...&#125; 正例:12345678910var menuConfig = &#123; title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true&#125;function createMenu(menuConfig) &#123; ...&#125; 回到目录 函数功能的单一性这是软件功能中最重要的原则之一。 功能不单一的函数将导致难以重构、测试和理解。功能单一的函数易于重构，并使代码更加干净。 反例:12345678function emailClients(clients) &#123; clients.forEach(client =&gt; &#123; let clientRecord = database.lookup(client); if (clientRecord.isActive()) &#123; email(client); &#125; &#125;);&#125; 正例:12345678910111213141516function emailClients(clients) &#123; clients.forEach(client =&gt; &#123; emailClientIfNeeded(client); &#125;);&#125;function emailClientIfNeeded(client) &#123; if (isClientActive(client)) &#123; email(client); &#125;&#125;function isClientActive(client) &#123; let clientRecord = database.lookup(client); return clientRecord.isActive();&#125; 回到目录 函数名应明确表明其功能反例:1234567function dateAdd(date, month) &#123; // ...&#125;let date = new Date();// 很难理解dateAdd(date, 1)是什么意思 正例:123456function dateAddMonth(date, month) &#123; // ...&#125;let date = new Date();dateAddMonth(date, 1); 回到目录 函数应该只做一层抽象当函数的需要的抽象多余一层时通常意味着函数功能过于复杂，需将其进行分解以提高其可重用性和可测试性。 反例:12345678910111213141516171819202122function parseBetterJSAlternative(code) &#123; let REGEXES = [ // ... ]; let statements = code.split(' '); let tokens; REGEXES.forEach((REGEX) =&gt; &#123; statements.forEach((statement) =&gt; &#123; // ... &#125;) &#125;); let ast; tokens.forEach((token) =&gt; &#123; // lex... &#125;); ast.forEach((node) =&gt; &#123; // parse... &#125;)&#125; 正例:1234567891011121314151617181920212223242526272829303132function tokenize(code) &#123; let REGEXES = [ // ... ]; let statements = code.split(' '); let tokens; REGEXES.forEach((REGEX) =&gt; &#123; statements.forEach((statement) =&gt; &#123; // ... &#125;) &#125;); return tokens;&#125;function lexer(tokens) &#123; let ast; tokens.forEach((token) =&gt; &#123; // lex... &#125;); return ast;&#125;function parseBetterJSAlternative(code) &#123; let tokens = tokenize(code); let ast = lexer(tokens); ast.forEach((node) =&gt; &#123; // parse... &#125;)&#125; 回到目录 移除重复的代码永远、永远、永远不要在任何循环下有重复的代码。 这种做法毫无意义且潜在危险极大。重复的代码意味着逻辑变化时需要对不止一处进行修改。JS弱类型的特点使得函数拥有更强的普适性。好好利用这一优点吧。 反例:1234567891011121314151617181920212223242526272829function showDeveloperList(developers) &#123; developers.forEach(developers =&gt; &#123; var expectedSalary = developer.calculateExpectedSalary(); var experience = developer.getExperience(); var githubLink = developer.getGithubLink(); var data = &#123; expectedSalary: expectedSalary, experience: experience, githubLink: githubLink &#125;; render(data); &#125;);&#125;function showManagerList(managers) &#123; managers.forEach(manager =&gt; &#123; var expectedSalary = manager.calculateExpectedSalary(); var experience = manager.getExperience(); var portfolio = manager.getMBAProjects(); var data = &#123; expectedSalary: expectedSalary, experience: experience, portfolio: portfolio &#125;; render(data); &#125;);&#125; 正例:123456789101112131415161718192021function showList(employees) &#123; employees.forEach(employee =&gt; &#123; var expectedSalary = employee.calculateExpectedSalary(); var experience = employee.getExperience(); var portfolio; if (employee.type === 'manager') &#123; portfolio = employee.getMBAProjects(); &#125; else &#123; portfolio = employee.getGithubLink(); &#125; var data = &#123; expectedSalary: expectedSalary, experience: experience, portfolio: portfolio &#125;; render(data); &#125;);&#125; 回到目录 采用默认参数精简代码反例:1234function writeForumComment(subject, body) &#123; subject = subject || 'No Subject'; body = body || 'No text';&#125; 正例:123function writeForumComment(subject = 'No subject', body = 'No text') &#123; ...&#125; 回到目录 使用Object.assign设置默认对象反例:12345678910111213141516var menuConfig = &#123; title: null, body: 'Bar', buttonText: null, cancellable: true&#125;function createMenu(config) &#123; config.title = config.title || 'Foo' config.body = config.body || 'Bar' config.buttonText = config.buttonText || 'Baz' config.cancellable = config.cancellable === undefined ? config.cancellable : true;&#125;createMenu(menuConfig); 正例:1234567891011121314151617181920var menuConfig = &#123; title: 'Order', // User did not include 'body' key buttonText: 'Send', cancellable: true&#125;function createMenu(config) &#123; config = Object.assign(&#123; title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true &#125;, config); // config now equals: &#123;title: \"Foo\", body: \"Bar\", buttonText: \"Baz\", cancellable: true&#125; // ...&#125;createMenu(menuConfig); 回到目录 不要使用标记(Flag)作为函数参数这通常意味着函数的功能的单一性已经被破坏。此时应考虑对函数进行再次划分。 反例:1234567function createFile(name, temp) &#123; if (temp) &#123; fs.create('./temp/' + name); &#125; else &#123; fs.create(name); &#125;&#125; 正例:1234567function createTempFile(name) &#123; fs.create('./temp/' + name);&#125;function createFile(name) &#123; fs.create(name);&#125; 回到目录 避免副作用当函数产生了除了“接受一个值并返回一个结果”之外的行为时，称该函数产生了副作用。比如写文件、修改全局变量或将你的钱全转给了一个陌生人等。 程序在某些情况下确实需要副作用这一行为，如先前例子中的写文件。这时应该将这些功能集中在一起，不要用多个函数/类修改某个文件。用且只用一个service完成这一需求。 反例:1234567891011// Global variable referenced by following function.// If we had another function that used this name, now it'd be an array and it could break it.var name = 'Ryan McDermott';function splitIntoFirstAndLastName() &#123; name = name.split(' ');&#125;splitIntoFirstAndLastName();console.log(name); // ['Ryan', 'McDermott']; 正例:123456789function splitIntoFirstAndLastName(name) &#123; return name.split(' ');&#125;var name = 'Ryan McDermott'var newName = splitIntoFirstAndLastName(name);console.log(name); // 'Ryan McDermott';console.log(newName); // ['Ryan', 'McDermott']; 回到目录 不要写全局函数在JS中污染全局是一个非常不好的实践，这么做可能和其他库起冲突，且调用你的API的用户在实际环境中得到一个exception前对这一情况是一无所知的。 想象以下例子：如果你想扩展JS中的Array，为其添加一个diff函数显示两个数组间的差异，此时应如何去做？你可以将diff写入Array.prototype，但这么做会和其他有类似需求的库造成冲突。如果另一个库对diff的需求为比较一个数组中收尾元素间的差异呢？ 使用ES6中的class对全局的Array做简单的扩展显然是一个更棒的选择。 反例:12345678910111213141516Array.prototype.diff = function(comparisonArray) &#123; var values = []; var hash = &#123;&#125;; for (var i of comparisonArray) &#123; hash[i] = true; &#125; for (var i of this) &#123; if (!hash[i]) &#123; values.push(i); &#125; &#125; return values;&#125; 正例:12345678910111213141516171819202122class SuperArray extends Array &#123; constructor(...args) &#123; super(...args); &#125; diff(comparisonArray) &#123; var values = []; var hash = &#123;&#125;; for (var i of comparisonArray) &#123; hash[i] = true; &#125; for (var i of this) &#123; if (!hash[i]) &#123; values.push(i); &#125; &#125; return values; &#125;&#125; 回到目录 采用函数式编程函数式的编程具有更干净且便于测试的特点。尽可能的使用这种风格吧。 反例:123456789101112131415161718192021const programmerOutput = [ &#123; name: 'Uncle Bobby', linesOfCode: 500 &#125;, &#123; name: 'Suzie Q', linesOfCode: 1500 &#125;, &#123; name: 'Jimmy Gosling', linesOfCode: 150 &#125;, &#123; name: 'Gracie Hopper', linesOfCode: 1000 &#125;];var totalOutput = 0;for (var i = 0; i &lt; programmerOutput.length; i++) &#123; totalOutput += programmerOutput[i].linesOfCode;&#125; 正例:12345678910111213141516171819const programmerOutput = [ &#123; name: 'Uncle Bobby', linesOfCode: 500 &#125;, &#123; name: 'Suzie Q', linesOfCode: 1500 &#125;, &#123; name: 'Jimmy Gosling', linesOfCode: 150 &#125;, &#123; name: 'Gracie Hopper', linesOfCode: 1000 &#125;];var totalOutput = programmerOutput .map((programmer) =&gt; programmer.linesOfCode) .reduce((acc, linesOfCode) =&gt; acc + linesOfCode, 0); 回到目录 封装判断条件反例:123if (fsm.state === 'fetching' &amp;&amp; isEmpty(listNode)) &#123; /// ...&#125; 正例:1234567function shouldShowSpinner(fsm, listNode) &#123; return fsm.state === 'fetching' &amp;&amp; isEmpty(listNode);&#125;if (shouldShowSpinner(fsmInstance, listNodeInstance)) &#123; // ...&#125; 回到目录 避免“否定情况”的判断反例:1234567function isDOMNodeNotPresent(node) &#123; // ...&#125;if (!isDOMNodeNotPresent(node)) &#123; // ...&#125; 正例:1234567function isDOMNodePresent(node) &#123; // ...&#125;if (isDOMNodePresent(node)) &#123; // ...&#125; 回到目录 避免条件判断这看起来似乎不太可能。 大多人听到这的第一反应是：“怎么可能不用if完成其他功能呢？”许多情况下通过使用多态(polymorphism)可以达到同样的目的。 第二个问题在于采用这种方式的原因是什么。答案是我们之前提到过的：保持函数功能的单一性。 反例:12345678910111213class Airplane &#123; //... getCruisingAltitude() &#123; switch (this.type) &#123; case '777': return getMaxAltitude() - getPassengerCount(); case 'Air Force One': return getMaxAltitude(); case 'Cessna': return getMaxAltitude() - getFuelExpenditure(); &#125; &#125;&#125; 正例:123456789101112131415161718192021222324class Airplane &#123; //...&#125;class Boeing777 extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude() - getPassengerCount(); &#125;&#125;class AirForceOne extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude(); &#125;&#125;class Cessna extends Airplane &#123; //... getCruisingAltitude() &#123; return getMaxAltitude() - getFuelExpenditure(); &#125;&#125; 回到目录 避免类型判断(part 1)JS是弱类型语言，这意味着函数可接受任意类型的参数。 有时这会对你带来麻烦，你会对参数做一些类型判断。有许多方法可以避免这些情况。 反例:1234567function travelToTexas(vehicle) &#123; if (vehicle instanceof Bicycle) &#123; vehicle.peddle(this.currentLocation, new Location('texas')); &#125; else if (vehicle instanceof Car) &#123; vehicle.drive(this.currentLocation, new Location('texas')); &#125;&#125; 正例:123function travelToTexas(vehicle) &#123; vehicle.move(this.currentLocation, new Location('texas'));&#125; 回到目录 避免类型判断(part 2)如果需处理的数据为字符串，整型，数组等类型，无法使用多态并仍有必要对其进行类型检测时，可以考虑使用TypeScript。 反例:12345678function combine(val1, val2) &#123; if (typeof val1 == \"number\" &amp;&amp; typeof val2 == \"number\" || typeof val1 == \"string\" &amp;&amp; typeof val2 == \"string\") &#123; return val1 + val2; &#125; else &#123; throw new Error('Must be of type String or Number'); &#125;&#125; 正例:123function combine(val1, val2) &#123; return val1 + val2;&#125; 回到目录 避免过度优化现代的浏览器在运行时会对代码自动进行优化。有时人为对代码进行优化可能是在浪费时间。 这里可以找到许多真正需要优化的地方 反例:1234567// 这里使用变量len是因为在老式浏览器中，// 直接使用正例中的方式会导致每次循环均重复计算list.length的值，// 而在现代浏览器中会自动完成优化，这一行为是没有必要的for (var i = 0, len = list.length; i &lt; len; i++) &#123; // ...&#125; 正例:123for (var i = 0; i &lt; list.length; i++) &#123; // ...&#125; 回到目录 删除无效的代码不再被调用的代码应及时删除。 反例:12345678910function oldRequestModule(url) &#123; // ...&#125;function newRequestModule(url) &#123; // ...&#125;var req = newRequestModule;inventoryTracker('apples', req, 'www.inventory-awesome.io'); 正例:123456function newRequestModule(url) &#123; // ...&#125;var req = newRequestModule;inventoryTracker('apples', req, 'www.inventory-awesome.io'); 回到目录 对象和数据结构使用getters和settersJS没有接口或类型，因此实现这一模式是很困难的，因为我们并没有类似public和private的关键词。 然而，使用getters和setters获取对象的数据远比直接使用点操作符具有优势。为什么呢？ 当需要对获取的对象属性执行额外操作时。 执行set时可以增加规则对要变量的合法性进行判断。 封装了内部逻辑。 在存取时可以方便的增加日志和错误处理。 继承该类时可以重载默认行为。 从服务器获取数据时可以进行懒加载。 反例:12345678910class BankAccount &#123; constructor() &#123; this.balance = 1000; &#125;&#125;let bankAccount = new BankAccount();// Buy shoes...bankAccount.balance = bankAccount.balance - 100; 正例:1234567891011121314151617class BankAccount &#123; constructor() &#123; this.balance = 1000; &#125; // It doesn't have to be prefixed with `get` or `set` to be a getter/setter withdraw(amount) &#123; if (verifyAmountCanBeDeducted(amount)) &#123; this.balance -= amount; &#125; &#125;&#125;let bankAccount = new BankAccount();// Buy shoes...bankAccount.withdraw(100); 回到目录 让对象拥有私有成员可以通过闭包完成 反例:12345678910111213var Employee = function(name) &#123; this.name = name;&#125;Employee.prototype.getName = function() &#123; return this.name;&#125;var employee = new Employee('John Doe');console.log('Employee name: ' + employee.getName()); // Employee name: John Doedelete employee.name;console.log('Employee name: ' + employee.getName()); // Employee name: undefined 正例:1234567891011121314var Employee = (function() &#123; function Employee(name) &#123; this.getName = function() &#123; return name; &#125;; &#125; return Employee;&#125;());var employee = new Employee('John Doe');console.log('Employee name: ' + employee.getName()); // Employee name: John Doedelete employee.name;console.log('Employee name: ' + employee.getName()); // Employee name: John Doe 回到目录 类单一职责原则 (SRP)如《代码整洁之道》一书中所述，“修改一个类的理由不应该超过一个”。 将多个功能塞进一个类的想法很诱人，但这将导致你的类无法达到概念上的内聚，并经常不得不进行修改。 最小化对一个类需要修改的次数是非常有必要的。如果一个类具有太多太杂的功能，当你对其中一小部分进行修改时，将很难想象到这一修够对代码库中依赖该类的其他模块会带来什么样的影响。 反例:123456789101112131415class UserSettings &#123; constructor(user) &#123; this.user = user; &#125; changeSettings(settings) &#123; if (this.verifyCredentials(user)) &#123; // ... &#125; &#125; verifyCredentials(user) &#123; // ... &#125;&#125; 正例:1234567891011121314151617181920212223class UserAuth &#123; constructor(user) &#123; this.user = user; &#125; verifyCredentials() &#123; // ... &#125;&#125;class UserSettings &#123; constructor(user) &#123; this.user = user; this.auth = new UserAuth(user) &#125; changeSettings(settings) &#123; if (this.auth.verifyCredentials()) &#123; // ... &#125; &#125;&#125; 回到目录 开/闭原则 (OCP)“代码实体(类，模块，函数等)应该易于扩展，难于修改。” 这一原则指的是我们应允许用户方便的扩展我们代码模块的功能，而不需要打开js文件源码手动对其进行修改。 反例:123456789101112class AjaxRequester &#123; constructor() &#123; // What if we wanted another HTTP Method, like DELETE? We would have to // open this file up and modify this and put it in manually. this.HTTP_METHODS = ['POST', 'PUT', 'GET']; &#125; get(url) &#123; // ... &#125;&#125; 正例:12345678910111213class AjaxRequester &#123; constructor() &#123; this.HTTP_METHODS = ['POST', 'PUT', 'GET']; &#125; get(url) &#123; // ... &#125; addHTTPMethod(method) &#123; this.HTTP_METHODS.push(method); &#125;&#125; 回到目录 利斯科夫替代原则 (LSP)“子类对象应该能够替换其超类对象被使用”。 也就是说，如果有一个父类和一个子类，当采用子类替换父类时不应该产生错误的结果。 反例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Rectangle &#123; constructor() &#123; this.width = 0; this.height = 0; &#125; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125; setWidth(width) &#123; this.width = width; &#125; setHeight(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Rectangle &#123; constructor() &#123; super(); &#125; setWidth(width) &#123; this.width = width; this.height = width; &#125; setHeight(height) &#123; this.width = height; this.height = height; &#125;&#125;function renderLargeRectangles(rectangles) &#123; rectangles.forEach((rectangle) =&gt; &#123; rectangle.setWidth(4); rectangle.setHeight(5); let area = rectangle.getArea(); // BAD: Will return 25 for Square. Should be 20. rectangle.render(area); &#125;)&#125;let rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles); 正例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Shape &#123; constructor() &#123;&#125; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125;&#125;class Rectangle extends Shape &#123; constructor() &#123; super(); this.width = 0; this.height = 0; &#125; setWidth(width) &#123; this.width = width; &#125; setHeight(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Shape &#123; constructor() &#123; super(); this.length = 0; &#125; setLength(length) &#123; this.length = length; &#125; getArea() &#123; return this.length * this.length; &#125;&#125;function renderLargeShapes(shapes) &#123; shapes.forEach((shape) =&gt; &#123; switch (shape.constructor.name) &#123; case 'Square': shape.setLength(5); case 'Rectangle': shape.setWidth(4); shape.setHeight(5); &#125; let area = shape.getArea(); shape.render(area); &#125;)&#125;let shapes = [new Rectangle(), new Rectangle(), new Square()];renderLargeShapes(shapes); 回到目录 接口隔离原则 (ISP)“客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。” 在JS中，当一个类需要许多参数设置才能生成一个对象时，或许大多时候不需要设置这么多的参数。此时减少对配置参数数量的需求是有益的。 反例:123456789101112131415161718192021class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.animationModule.setup(); &#125; traverse() &#123; // ... &#125;&#125;let $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName('body'), animationModule: function() &#123;&#125; // Most of the time, we won't need to animate when traversing. // ...&#125;); 正例:1234567891011121314151617181920212223242526272829class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.options = settings.options; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.setupOptions(); &#125; setupOptions() &#123; if (this.options.animationModule) &#123; // ... &#125; &#125; traverse() &#123; // ... &#125;&#125;let $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName('body'), options: &#123; animationModule: function() &#123;&#125; &#125;&#125;); 回到目录 依赖反转原则 (DIP)该原则有两个核心点: 高层模块不应该依赖于低层模块。他们都应该依赖于抽象接口。 抽象接口应该脱离具体实现，具体实现应该依赖于抽象接口。 反例:12345678910111213141516171819202122232425262728class InventoryTracker &#123; constructor(items) &#123; this.items = items; // BAD: We have created a dependency on a specific request implementation. // We should just have requestItems depend on a request method: `request` this.requester = new InventoryRequester(); &#125; requestItems() &#123; this.items.forEach((item) =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;class InventoryRequester &#123; constructor() &#123; this.REQ_METHODS = ['HTTP']; &#125; requestItem(item) &#123; // ... &#125;&#125;let inventoryTracker = new InventoryTracker(['apples', 'bananas']);inventoryTracker.requestItems(); 正例:12345678910111213141516171819202122232425262728293031323334353637class InventoryTracker &#123; constructor(items, requester) &#123; this.items = items; this.requester = requester; &#125; requestItems() &#123; this.items.forEach((item) =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;class InventoryRequesterV1 &#123; constructor() &#123; this.REQ_METHODS = ['HTTP']; &#125; requestItem(item) &#123; // ... &#125;&#125;class InventoryRequesterV2 &#123; constructor() &#123; this.REQ_METHODS = ['WS']; &#125; requestItem(item) &#123; // ... &#125;&#125;// By constructing our dependencies externally and injecting them, we can easily// substitute our request module for a fancy new one that uses WebSockets.let inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());inventoryTracker.requestItems(); 回到目录 使用ES6的classes而不是ES5的Function典型的ES5的类(function)在继承、构造和方法定义方面可读性较差。 当需要继承时，优先选用classes。 但是，当在需要更大更复杂的对象时，最好优先选择更小的function而非classes。 反例:1234567891011121314151617181920212223242526272829303132333435var Animal = function(age) &#123; if (!(this instanceof Animal)) &#123; throw new Error(\"Instantiate Animal with `new`\"); &#125; this.age = age;&#125;;Animal.prototype.move = function() &#123;&#125;;var Mammal = function(age, furColor) &#123; if (!(this instanceof Mammal)) &#123; throw new Error(\"Instantiate Mammal with `new`\"); &#125; Animal.call(this, age); this.furColor = furColor;&#125;;Mammal.prototype = Object.create(Animal.prototype);Mammal.prototype.constructor = Mammal;Mammal.prototype.liveBirth = function() &#123;&#125;;var Human = function(age, furColor, languageSpoken) &#123; if (!(this instanceof Human)) &#123; throw new Error(\"Instantiate Human with `new`\"); &#125; Mammal.call(this, age, furColor); this.languageSpoken = languageSpoken;&#125;;Human.prototype = Object.create(Mammal.prototype);Human.prototype.constructor = Human;Human.prototype.speak = function() &#123;&#125;; 正例:12345678910111213141516171819202122232425class Animal &#123; constructor(age) &#123; this.age = age; &#125; move() &#123;&#125;&#125;class Mammal extends Animal &#123; constructor(age, furColor) &#123; super(age); this.furColor = furColor; &#125; liveBirth() &#123;&#125;&#125;class Human extends Mammal &#123; constructor(age, furColor, languageSpoken) &#123; super(age, furColor); this.languageSpoken = languageSpoken; &#125; speak() &#123;&#125;&#125; 回到目录 使用方法链这里我们的理解与《代码整洁之道》的建议有些不同。 有争论说方法链不够干净且违反了德米特法则,也许这是对的，但这种方法在JS及许多库(如JQuery)中显得非常实用。 因此，我认为在JS中使用方法链是非常合适的。在class的函数中返回this，能够方便的将类需要执行的多个方法链接起来。 反例:1234567891011121314151617181920212223242526272829class Car &#123; constructor() &#123; this.make = 'Honda'; this.model = 'Accord'; this.color = 'white'; &#125; setMake(make) &#123; this.name = name; &#125; setModel(model) &#123; this.model = model; &#125; setColor(color) &#123; this.color = color; &#125; save() &#123; console.log(this.make, this.model, this.color); &#125;&#125;let car = new Car();car.setColor('pink');car.setMake('Ford');car.setModel('F-150')car.save(); 正例:1234567891011121314151617181920212223242526272829303132333435class Car &#123; constructor() &#123; this.make = 'Honda'; this.model = 'Accord'; this.color = 'white'; &#125; setMake(make) &#123; this.name = name; // NOTE: Returning this for chaining return this; &#125; setModel(model) &#123; this.model = model; // NOTE: Returning this for chaining return this; &#125; setColor(color) &#123; this.color = color; // NOTE: Returning this for chaining return this; &#125; save() &#123; console.log(this.make, this.model, this.color); &#125;&#125;let car = new Car() .setColor('pink') .setMake('Ford') .setModel('F-150') .save(); 回到目录 优先使用组合模式而非继承在著名的设计模式一书中提到，应多使用组合模式而非继承。 这么做有许多优点，在想要使用继承前，多想想能否通过组合模式满足需求吧。 那么，在什么时候继承具有更大的优势呢？这取决于你的具体需求，但大多情况下，可以遵守以下三点： 继承关系表现为”是一个”而非”有一个”(如动物-&gt;人 和 用户-&gt;用户细节) 可以复用基类的代码(“Human”可以看成是”All animal”的一种) 希望当基类改变时所有派生类都受到影响(如修改”all animals”移动时的卡路里消耗量) 反例:12345678910111213141516171819class Employee &#123; constructor(name, email) &#123; this.name = name; this.email = email; &#125; // ...&#125;// Bad because Employees \"have\" tax data. EmployeeTaxData is not a type of Employeeclass EmployeeTaxData extends Employee &#123; constructor(ssn, salary) &#123; super(); this.ssn = ssn; this.salary = salary; &#125; // ...&#125; 正例:123456789101112131415161718192021class Employee &#123; constructor(name, email) &#123; this.name = name; this.email = email; &#125; setTaxData(ssn, salary) &#123; this.taxData = new EmployeeTaxData(ssn, salary); &#125; // ...&#125;class EmployeeTaxData &#123; constructor(ssn, salary) &#123; this.ssn = ssn; this.salary = salary; &#125; // ...&#125; 回到目录 测试一些好的覆盖工具. 一些好的JS测试框架 单一的测试每个概念反例:12345678910111213141516171819const assert = require('assert');describe('MakeMomentJSGreatAgain', function() &#123; it('handles date boundaries', function() &#123; let date; date = new MakeMomentJSGreatAgain('1/1/2015'); date.addDays(30); date.shouldEqual('1/31/2015'); date = new MakeMomentJSGreatAgain('2/1/2016'); date.addDays(28); assert.equal('02/29/2016', date); date = new MakeMomentJSGreatAgain('2/1/2015'); date.addDays(28); assert.equal('03/01/2015', date); &#125;);&#125;); 正例:123456789101112131415161718192021const assert = require('assert');describe('MakeMomentJSGreatAgain', function() &#123; it('handles 30-day months', function() &#123; let date = new MakeMomentJSGreatAgain('1/1/2015'); date.addDays(30); date.shouldEqual('1/31/2015'); &#125;); it('handles leap year', function() &#123; let date = new MakeMomentJSGreatAgain('2/1/2016'); date.addDays(28); assert.equal('02/29/2016', date); &#125;); it('handles non-leap year', function() &#123; let date = new MakeMomentJSGreatAgain('2/1/2015'); date.addDays(28); assert.equal('03/01/2015', date); &#125;);&#125;); 回到目录 并发用Promises替代回调回调不够整洁并会造成大量的嵌套。ES6内嵌了Promises，使用它吧。 反例:1234567891011121314require('request').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin', function(err, response) &#123; if (err) &#123; console.error(err); &#125; else &#123; require('fs').writeFile('article.html', response.body, function(err) &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log('File written'); &#125; &#125;) &#125;&#125;) 正例:12345678910require('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin') .then(function(response) &#123; return require('fs-promise').writeFile('article.html', response); &#125;) .then(function() &#123; console.log('File written'); &#125;) .catch(function(err) &#123; console.error(err); &#125;) 回到目录 Async/Await是较Promises更好的选择Promises是较回调而言更好的一种选择，但ES7中的async和await更胜过Promises。 在能使用ES7特性的情况下可以尽量使用他们替代Promises。 反例:12345678910require('request-promise').get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin') .then(function(response) &#123; return require('fs-promise').writeFile('article.html', response); &#125;) .then(function() &#123; console.log('File written'); &#125;) .catch(function(err) &#123; console.error(err); &#125;) 正例:123456789101112async function getCleanCodeArticle() &#123; try &#123; var request = await require('request-promise') var response = await request.get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin'); var fileHandle = await require('fs-promise'); await fileHandle.writeFile('article.html', response); console.log('File written'); &#125; catch(err) &#123; console.log(err); &#125; &#125; 回到目录 错误处理错误抛出是个好东西！这使得你能够成功定位运行状态中的程序产生错误的位置。 别忘了捕获错误对捕获的错误不做任何处理是没有意义的。 代码中try/catch的意味着你认为这里可能出现一些错误，你应该对这些可能的错误存在相应的处理方案。 反例:12345try &#123; functionThatMightThrow();&#125; catch (error) &#123; console.log(error);&#125; 正例:1234567891011try &#123; functionThatMightThrow();&#125; catch (error) &#123; // One option (more noisy than console.log): console.error(error); // Another option: notifyUserOfError(error); // Another option: reportErrorToService(error); // OR do all three!&#125; 不要忽略被拒绝的promises理由同try/catch. 反例:1234567getdata().then(data =&gt; &#123; functionThatMightThrow(data);&#125;).catch(error =&gt; &#123; console.log(error);&#125;); 正例:12345678910111213getdata().then(data =&gt; &#123; functionThatMightThrow(data);&#125;).catch(error =&gt; &#123; // One option (more noisy than console.log): console.error(error); // Another option: notifyUserOfError(error); // Another option: reportErrorToService(error); // OR do all three!&#125;); 回到目录 格式化格式化是一件主观的事。如同这里的许多规则一样，这里并没有一定/立刻需要遵守的规则。可以在这里完成格式的自动化。 大小写一致JS是弱类型语言，合理的采用大小写可以告诉你关于变量/函数等的许多消息。 这些规则是主观定义的，团队可以根据喜欢进行选择。重点在于无论选择何种风格，都需要注意保持一致性。 反例:1234567891011var DAYS_IN_WEEK = 7;var daysInMonth = 30;var songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];var Artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];function eraseDatabase() &#123;&#125;function restore_database() &#123;&#125;class animal &#123;&#125;class Alpaca &#123;&#125; 正例:1234567891011var DAYS_IN_WEEK = 7;var DAYS_IN_MONTH = 30;var songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];var artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];function eraseDatabase() &#123;&#125;function restoreDatabase() &#123;&#125;class Animal &#123;&#125;class Alpaca &#123;&#125; 回到目录 调用函数的函数和被调函数应放在较近的位置当函数间存在相互调用的情况时，应将两者置于较近的位置。 理想情况下，应将调用其他函数的函数写在被调用函数的上方。 反例:1234567891011121314151617181920212223242526272829303132333435class PerformanceReview &#123; constructor(employee) &#123; this.employee = employee; &#125; lookupPeers() &#123; return db.lookup(this.employee, 'peers'); &#125; lookupMananger() &#123; return db.lookup(this.employee, 'manager'); &#125; getPeerReviews() &#123; let peers = this.lookupPeers(); // ... &#125; perfReview() &#123; getPeerReviews(); getManagerReview(); getSelfReview(); &#125; getManagerReview() &#123; let manager = this.lookupManager(); &#125; getSelfReview() &#123; // ... &#125;&#125;let review = new PerformanceReview(user);review.perfReview(); 正例:1234567891011121314151617181920212223242526272829303132333435class PerformanceReview &#123; constructor(employee) &#123; this.employee = employee; &#125; perfReview() &#123; getPeerReviews(); getManagerReview(); getSelfReview(); &#125; getPeerReviews() &#123; let peers = this.lookupPeers(); // ... &#125; lookupPeers() &#123; return db.lookup(this.employee, 'peers'); &#125; getManagerReview() &#123; let manager = this.lookupManager(); &#125; lookupMananger() &#123; return db.lookup(this.employee, 'manager'); &#125; getSelfReview() &#123; // ... &#125;&#125;let review = new PerformanceReview(employee);review.perfReview(); 回到目录 注释只对存在一定业务逻辑复制性的代码进行注释注释并不是必须的，好的代码是能够让人一目了然，不用过多无谓的注释。 反例:1234567891011121314151617function hashIt(data) &#123; // The hash var hash = 0; // Length of string var length = data.length; // Loop through every character in data for (var i = 0; i &lt; length; i++) &#123; // Get character code. var char = data.charCodeAt(i); // Make the hash hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; &#125;&#125; 正例:12345678910111213function hashIt(data) &#123; var hash = 0; var length = data.length; for (var i = 0; i &lt; length; i++) &#123; var char = data.charCodeAt(i); hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; &#125;&#125; 回到目录 不要在代码库中遗留被注释掉的代码版本控制的存在是有原因的。让旧代码存在于你的history里吧。 反例:1234doStuff();// doOtherStuff();// doSomeMoreStuff();// doSoMuchStuff(); 正例:1doStuff(); 回到目录 不需要版本更新类型注释记住，我们可以使用版本控制。废代码、被注释的代码及用注释记录代码中的版本更新说明都是没有必要的。 需要时可以使用git log获取历史版本。 反例:123456789/** * 2016-12-20: Removed monads, didn't understand them (RM) * 2016-10-01: Improved using special monads (JP) * 2016-02-03: Removed type-checking (LI) * 2015-03-14: Added combine with type-checking (JR) */function combine(a, b) &#123; return a + b;&#125; 正例:123function combine(a, b) &#123; return a + b;&#125; 回到目录 避免位置标记这些东西通常只能代码麻烦，采用适当的缩进就可以了。 反例:1234567891011121314////////////////////////////////////////////////////////////////////////////////// Scope Model Instantiation////////////////////////////////////////////////////////////////////////////////let $scope.model = &#123; menu: 'foo', nav: 'bar'&#125;;////////////////////////////////////////////////////////////////////////////////// Action setup////////////////////////////////////////////////////////////////////////////////let actions = function() &#123; // ...&#125; 正例:12345678let $scope.model = &#123; menu: 'foo', nav: 'bar'&#125;;let actions = function() &#123; // ...&#125; 回到目录 避免在源文件中写入法律评论将你的LICENSE文件置于源码目录树的根目录。 反例:123456789101112131415161718192021222324252627/*The MIT License (MIT)Copyright (c) 2016 Ryan McDermottPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the \"Software\"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE*/function calculateBill() &#123; // ...&#125; 正例:123function calculateBill() &#123; // ...&#125; 回到目录 转载：https://github.com/ZetaoYang/clean-code-js","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuyouyou.github.io/tags/JavaScript/"}]},{"title":"降低网页加载时间","date":"2017-03-15T07:36:18.000Z","path":"2017/03/15/reduce-loading/","text":"&nbsp;&nbsp;&nbsp;&nbsp;降低网页加载时间的方案太多了，在网上一查多的看不过来，所以我结合自身用到的以及网上的方案，来归纳一下吧，主要是一些前端能做的事情，以后get到新的方案，再不断添加吧。(╯▽╰)&nbsp;&nbsp;&nbsp;&nbsp;其实网页加载就是请求HTML，再顺带将它依赖的资源文件（比如：JS/CSS/iconfont）一并请求过来。从概念出发，我们就可以得出降低网页加载时间，最本质的方式就是：减少请求数量 与 减小请求大小。一、减少请求数量 优化图像1、将小图标合并成sprite图&nbsp;&nbsp;&nbsp;&nbsp;我们可以把多张背景图片和小图标合并雪碧图，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数。2、使用iconfont字体图标&nbsp;&nbsp;&nbsp;&nbsp;sprite图不适合无线端的响应式场景，所以越来越作为一个备用方案，而很多时候可以用iconfont字体来代替一些小图标。它就是用字体编码的形式来实现图标效果，既然是文字，那就可以随意设置颜色设置大小，相对来说比sprite方案更好，但是它只适用于纯色图标。3、base64:URL背景图片&nbsp;&nbsp;&nbsp;&nbsp;使用base64图可以减少HTTP请求，还可以避免跨域的问题。不了解的可以直接点击：详情传送门4、图片延迟加载&nbsp;&nbsp;&nbsp;&nbsp;图片延迟加载也称懒加载，常用于页面很长，图片很多的页面，整个页面少说几百K，多则上兆，如果想一次性加载完成，不仅用户要哭了，服务器也得哭了。为了避免这种请况发生，目前主流的做法是页面初次加载时，只显示当前可视区域的图片，当用户滚动页面的时候，当图片进入可视区域时再加载，这样可以明显的提高页面加载速度，而更少的图片并发请求数，也可以大大的减轻服务器的压力。5、标明图片高度和宽度&nbsp;&nbsp;&nbsp;&nbsp;如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。 Ajax调用尽量采用GET方法&nbsp;&nbsp;&nbsp;&nbsp;实际使用XMLHttpRequest时，如果使用POST方法实现，会发生2次HTTP请求，而使用GET方法只会发生1次HTTP请求。如果改用GET方法，HTTP请求减少50%。 避免使用@import&nbsp;&nbsp;&nbsp;&nbsp;css @import语法允许你加载其它的CSS文件。有时非常有帮助，但是它并不是和主文件一起下载的，只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作，因此css @import引起的css解析延迟会加长页面留白期。 所以，要尽量避免使用css @import而采用link标签的方式引入。 二、减小请求大小 JS/CSS/HTML压缩&nbsp;&nbsp;&nbsp;&nbsp;很多公司都采用了这个手段，就不介绍太多，主要的方式有：1、通过构建工具实现，比如webpack/gulp/fis/grunt等。2、后台预编译。3、利用第三方online平台，手动上传压缩。 图片压缩&nbsp;&nbsp;&nbsp;&nbsp;同上可以手动处理图片或者借助第三方平台，手动处理的话推荐一个网站 tinypng，或者用第三方平台，比如七牛云平台。 三、其他方案 利用浏览器缓存&nbsp;&nbsp;&nbsp;&nbsp;浏览器缓存是允许访客的浏览器缓存你网站页面副本的一个功能。这有助于访客再次访问时，直接从缓存中读取内容而不必重新加载。这节省了向服务器发送HTTP请求的时间。 网址后加斜杠&nbsp;&nbsp;&nbsp;&nbsp;当用户打开一个链接时，服务器会推测链接这个地址包含哪种文件或页面。如果在连接后加上斜线（ / ），服务器就知道这是一个目录页，这样做可以减少页面的加载时间。如www.baidu.com/目录，会判断这个“目录是什么文件类型，或者是目录。 添加文件过期或缓存头&nbsp;&nbsp;&nbsp;&nbsp;同一用户频繁访问的图片、Js脚本文件等可以在Apache或Nginx设置其缓冲 时间，例如设置24小时过期时间，这样用户在访问过该页面之后再次访问时，同一组图片或JS不会再重复下载，从而减少了HTTP请求，用户访问速度明显有 所提升，同时服务器负载也会下降。 减少DNS查询&nbsp;&nbsp;&nbsp;&nbsp;减少DNS查询是一个WEB开发人员可以用了页面加载时间快速有效的方法。DNS查询需要话费很长的时间来返回一个主机名的IP地址。而浏览器在查询结束前不会进行任何操作。对于不同的元素可以使用不同的主机名，如URL、图像、脚本文件、样式文件、FLASH元素等。具有多种网络元素的页面经常需要进行多个DNS查询，因而花费的时间更长。减少不同域名的数量将减少并行下载的数量，加速你的网站。 最小化重定向&nbsp;&nbsp;&nbsp;&nbsp;重定向增加了额外的HTTP请求，因此也增加了页面加载时间。然而有时重定向却是不可避免的，如链接网站的不同部分、保存多个域名、或者从不存在的页面跳转到新页面。重定向增加了延迟时间，因此要尽量避免使用它。检查是否有损坏的链接，并立即修复。 CSS和JS的文件位置&nbsp;&nbsp;&nbsp;&nbsp;把CSS文件在页面底部引入可以禁止逐步渲染，节省浏览器加载和重绘页面元素的资源。把JS文件放在页面底部可以避免代码执行前的等待时间，从而提升页面加载速度。但是在某些情况下，需要JS在页面的顶部加载（如某些第三方跟踪脚本）。 延迟加载ga统计&nbsp;&nbsp;&nbsp;&nbsp;ga统计代码不阻塞页面渲染，不阻塞后续请求，但会阻塞window.onload事件，页面的表现方式是进度条一直加载。所以我们延迟执行ga初始化代码，将其放到window.onload函数中去执行，可以防止ga脚本阻塞window.onload事件。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yuyouyou.github.io/tags/性能优化/"}]},{"title":"函数节流与防抖","date":"2017-03-13T02:04:25.000Z","path":"2017/03/13/throttle/","text":"函数节流&nbsp;&nbsp;&nbsp;&nbsp;我们网站经常会有这样的需求，就是滚动浏览器滚动条的时候，更新页面上的某些布局内容或者去调用后台的某接口查询内容。如果不对函数调用的频率加以限制的话，那么可能我们滚动一次滚动条就会产生N次的调用了。所以我们每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。为了更好的理解这个概念，我们先来完成一个小需求，就是浏览器滚动条在滚动过程中打印n值：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;函数节流与防抖&lt;/title&gt;&lt;/head&gt;&lt;body style=\"height:1000px\"&gt;&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; window.onscroll=funHandler;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &nbsp;&nbsp;&nbsp;&nbsp;功能倒是实现了，但是看一下控制台可以发现频繁的在打印n值，如果我们的 funHandler() 方法是 ajax 向服务器发送请求，那还得了啊！ &nbsp;&nbsp;&nbsp;&nbsp;下面我们利用函数节流的两种方案来完成这个需求：&nbsp;&nbsp;&nbsp;&nbsp;第一种是按照《JavaScript高级程序设计》中的函数节流方法，原理很简单，利用定时器，让函数执行延迟500毫秒，在500毫秒内如果有函数又被调用则删除上一次调用，这次调用500毫秒后执行，如此往复。这样我刚才的代码可以改为：1234567891011121314151617&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; function throttle(method,context)&#123; clearTimeout(method.tId); method.tId=setTimeout(function()&#123; method.call(context); &#125;,500); &#125; window.onscroll=function()&#123; throttle(funHandler,window); &#125;;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;滚动一下试试，果真只执行了一次 &nbsp;&nbsp;&nbsp;&nbsp;第二种是网上的一种节流方案，调试一下试试，效果和刚才是一样的：123456789101112131415161718&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; function throttle(method,delay)&#123; var timer=null; return function()&#123; var context=this, args=arguments; clearTimeout(timer); timer=setTimeout(function()&#123; method.apply(context,args); &#125;,delay); &#125; &#125; window.onscroll=throttle(funHandler,500);&lt;/script&gt; 函数防抖&nbsp;&nbsp;&nbsp;&nbsp;再来一个类似的需求，就像百度首页输入自动提示一样的东西，我在text上绑定keyup事件，每次键盘弹起的时候自动提示，但是又不想提示那么频繁，于是我用了上面方法，但是悲剧了，只有停止输入等500毫秒才会提示，在输入过程中根本就没有提示。看了一下代码，可不是嘛，只要是用户会盲打，在500毫秒内按一下键盘，提示函数就会不断被延迟，这样只有停下来的时候才会提示，这就没意义了。这个时候就用到了函数防抖，函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。其实它是在函数节流的基础上间隔固定时间来执行一次。如下所示：12345678910111213141516171819202122232425262728&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; function throttle(method,delay,duration)&#123; var timer=null, begin=new Date();// 记录下开始执行函数的时间 return function()&#123; var context=this, args=arguments, current=new Date();// 记录下当前时间 // 函数节流里的思路 clearTimeout(timer); // 记录下的两个时间相减再与duration进行比较 if(current-begin&gt;=duration)&#123; method.apply(context,args); begin=current; &#125;else&#123; timer=setTimeout(function()&#123; method.apply(context,args); &#125;,delay); &#125; &#125;&#125; window.onscroll=throttle(funHandler,500,2000);//因为返回函数句柄，不用包装函数了&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;这样每次我们判断间隔了多久，要是超过设置时间则立即执行一次，以刚才例子试一试效果，发现果真既没有频繁执行也没有就最后执行，感兴趣的朋友们可以试试哟！","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuyouyou.github.io/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yuyouyou.github.io/tags/性能优化/"}]},{"title":"charles使用教程","date":"2017-03-02T09:20:04.000Z","path":"2017/03/02/charles/","text":"&nbsp;&nbsp;&nbsp;&nbsp;记得我大三的时候有一门课叫计算机网络,是我最喜欢的王勇老师上的,当时勇哥给我们介绍了抓包工具,也是我第一次接触这玩意儿,当时用的wireshark,除了这个工具的名字貌似我什么都不记得了(&gt;_&lt;|||)。当时觉得这个工具应该和我以后的工作没多大联系吧,没想到出来做前端后,经常要用到抓包工具,特别是用来进行前端调试,觉得太赞了,我们可以用本地的文件来替换线上的文件,从而修复一些bug,还可以模拟不同的网络环境,或者设置网络请求。。。推荐一下我常用的两款抓包工具吧,一是fiddler,再就是我接下来介绍的charles。&nbsp;&nbsp;&nbsp;&nbsp;Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。工具就介绍这么多了,接下来介绍一下主要功能吧。 将 Charles 设置成系统代理&nbsp;&nbsp;&nbsp;&nbsp;选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示： &nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。 用 Map 功能来修改服务器返回内容&nbsp;&nbsp;&nbsp;&nbsp;Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。下面我来举一个 “Map Local” 的栗子: &nbsp;&nbsp;&nbsp;&nbsp;第一步:选择需要抓包的请求,并且保存文件到本地,如下图所示,我们来抓取 http://yuyouyou.github.io/ 下面的main.js文件: &nbsp;&nbsp;&nbsp;&nbsp;第二步:设置“Map Local”,如下图所示: &nbsp;&nbsp;&nbsp;&nbsp;第三步:打开刚才抓取的js文件,并且编辑一下再保存,如下图所示: &nbsp;&nbsp;&nbsp;&nbsp;现在访问 http://yuyouyou.github.io/ 就可以看到修改后的js文件替换了线上的js文件,是不是很酷啊,这对于我们调试线上的文件非常有帮助。 过滤网络请求&nbsp;&nbsp;&nbsp;&nbsp;如果我们需要只监控向指定目录服务器上发送的请求。有以下几种方法： &nbsp;&nbsp;&nbsp;&nbsp;方法一:在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yuyouyou.github.io/ , 那么只需要在 Filter 栏中填入 yuyouyou 即可。 &nbsp;&nbsp;&nbsp;&nbsp;方法二：在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示： &nbsp;&nbsp;&nbsp;&nbsp;方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示： 给服务器做压力测试&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力。我们在需要打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。 截取 iPhone 上的网络封包 Charles 上的设置&nbsp;&nbsp;&nbsp;&nbsp;要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。 iPhone 上的设置&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址。然后,在 iPhone 的 “ 设置 “-&gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888。设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单，点击 “Allow” 即可完成设置。接下来就可以愉快的抓取手机的请求了(^∀^)。 模拟慢速网络&nbsp;&nbsp;&nbsp;&nbsp;在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：","tags":[{"name":"抓包","slug":"抓包","permalink":"http://yuyouyou.github.io/tags/抓包/"},{"name":"网络","slug":"网络","permalink":"http://yuyouyou.github.io/tags/网络/"}]},{"title":"浏览器的重绘与重排","date":"2016-06-08T08:39:04.000Z","path":"2016/06/08/repaint-reflow/","text":"&nbsp;&nbsp;&nbsp;&nbsp;在前端开发中，性能优化是非常重要的一个环节，而谈到性能优化，我们就不得不了解一下浏览器的重绘与重排概念。 &nbsp;&nbsp;&nbsp;&nbsp;通常在 文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属 性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再 根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次 计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。 &nbsp;&nbsp;&nbsp;&nbsp;重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。 &nbsp;&nbsp;&nbsp;&nbsp;重排是更明显的一种改变，可以理解为渲染树需要重新计算。下面是常见的触发重排的操作： DOM元素的几何属性变化 &nbsp;&nbsp;&nbsp;&nbsp;当DOM元素的几何属性变化时，渲染树中的相关节点就会失效，浏览器会根据DOM元素的变化重新构建渲染树中失效的节点。之后，会根据新的渲染 树重新绘制这部分页面。而且，当前元素的重排也许会带来相关元素的重排。例如，容器节点的渲染树改变时，会触发子节点的重新计算，也会触发其后续兄弟节点 的重排，祖先节点需要重新计算子节点的尺寸也会产生重排。最后，每个元素都将发生重绘。可见，重排一定会引起浏览器的重绘，一个元素的重排通常会带来一系 列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。 DOM树的结构变化 &nbsp;&nbsp;&nbsp;&nbsp;当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器引擎布局的过程，类似于树的前序遍历，是一个从上到下从左到右的过程。 通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。所以，如果在body最前面插入一个元素，会导致整个文档的重新渲染，而在其后插入一个元 素，则不会影响到前面的元素。 获取某些属性 &nbsp;&nbsp;&nbsp;&nbsp;浏览器引擎可能会针对重排做了优化。比如Opera，它会等到有足够数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这 样就只发生一次重排。但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包 括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。 &nbsp;&nbsp;&nbsp;&nbsp;开发中，比较好的实践是尽量减少重排次数和缩小重排的影响范围。例如： 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。 需要多次重排的元素，position值最好为absolute或者fix，让它脱离文档流，这样就不会影响其他元素。所以有动画效果的元素最好设置绝对定位。 将多次改变样式属性的操作合并为一次操作，也就是将需要改变的的样式写在css中，并给一个类名，在js中只需要改变className即可。 由于display为none的元素不再渲染树中，对隐藏元素的操作不会引发其他元素的重排。如果要对一个元素进行复杂操作，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。 需要增加多个节点，可以一次性构建一个html片段，然后一次性添加到文档中去，而不是循环添加每一行。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yuyouyou.github.io/tags/性能优化/"}]},{"title":"windows下MongoDB的安装及配置","date":"2016-04-05T05:49:50.000Z","path":"2016/04/05/windows-mongodb/","text":"1、进入mongodb官网进行软件包下载。 2、选择windows平台，如图所示： 3、将zip文件解压放到盘符的根目录（如C：或D：），为了方便建议文件夹命名尽量简短如（d:\\mongodb）。 4、创建数据库文件的存放位置，比如d:/mongodb/data/db。启动mongodb服务之前必须创建数据库文件的存放文件夹，否则命令不会自动创建，而且不能启动成功。 5、打开cmd命令行，进入D:\\mongodb\\bin目录，输入如下的命令启动mongodb服务：1D:/mongodb/bin&gt;mongod --dbpath D:\\mongodb\\data\\db 6、mongodb默认连接端口27017，如果出现如图的情况，可以打开localhost:27017查看，发现如图则表示连接成功，如果不成功，可以查看端口是否被占用。 7、其实可以将MongoDB设置成Windows服务，这样每次开机MongoDB就自动启动了。 如图在d:\\mongodb\\data下新建文件夹log（存放日志文件）并且新建文件mongodb.log，在d:\\mongodb新建文件mongo.config。 8、用记事本打开mongo.config输入：12dbpath=D:\\mongodb\\data\\dblogpath=D:\\mongodb\\data\\log\\mongo.log 9、用管理员身份打开cmd命令行，进入D:\\mongodb\\bin目录，输入如下的命令：1D:\\mongodb\\bin&gt;mongod --config D:\\mongodb\\mongo.config 如果不成功可以改为如下：1mongod --config D:\\mongodb\\mongo.config --install --serviceName \"MongoDB\" 进入日志文件，查看日志发现已经成功了。如果失败有可能没有使用管理员身份，遭到拒绝访问。 10、打开cmd输入services.msc查看服务可以看到MongoDB服务，点击可以启动。如下所示：","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yuyouyou.github.io/tags/MongoDB/"}]},{"title":"smarty学习笔记","date":"2016-03-23T10:19:51.000Z","path":"2016/03/23/smarty/","text":"日期格式 12345678910111213141516171819&#123;%$time|date_format:'%Y-%m-%d'%&#125; 格式为2016-08-03&#123;%$time|date_format:'%H:%M:%S'%&#125; 格式为14:33:00常见的：%Y 年, 数字, 4 位%y 年, 数字, 2 位%m 月份, 数字(01……12)%c 月份, 数字(1……12)%b 缩写的月份名字(Jan……Dec)%d 月份中的天数, 数字(00……31)%e 月份中的天数, 数字(0……31)%H 小时(00……23)%k 小时(0……23)%I 小时(01……12)%l 小时(1……12)%M 分钟(00……59)%S 秒(00……59)%w 星期名字(Sunday……Saturday)%a 缩写的星期名字(Sun……Sat) 取循环中的特殊地方 12345678910such as:&#123;%foreach $item.tags as $tag name=tags%&#125; &#123;%if $smarty.foreach.tags.last%&#125;,&#123;%/if%&#125;&#123;%/foreach%&#125;index表示当前数组索引，从0开始计算iteration表示当前循环次数，从1开始计算first表示第一个last表示最后一个total表示循环总次数 strip去除多余空格 123456$articleTitle=‘Grandmother of\\neight makes\\t hole in one.’&#123;%$articleTitle%&#125; Grandmother of eight makes hole in one.&#123;%$articleTitle|strip%&#125; Grandmother of eight makes hole in one.&#123;%$articleTitle|strip:\"&amp;nbsp;\"%&#125; Grandmother&amp;nbsp;of&amp;nbsp;eight&amp;nbsp;makes&amp;nbsp;hole&amp;nbsp;in&amp;nbsp;one. strip_tags去除html标签 1234$articleTitle=‘Blind Woman Gets &lt;font face=\\\"helvetica\\\"&gt;New Kidney&lt;/font&gt; from Dad she Hasn't Seen in &lt;b&gt;years&lt;/b&gt;.’&#123;%$articleTitle%&#125; Blind Woman Gets &lt;font face=\"helvetica\"&gt;New Kidney&lt;/font&gt; from Dad she Hasn't Seen in &lt;b&gt;years&lt;/b&gt;.&#123;%$articleTitle|strip_tags%&#125; Blind Woman Gets New Kidney from Dad she Hasn't Seen in years. assign 为模板变量赋值 1234&#123;%assign var=\"name\" value=\"Bob\"%&#125;The value of $name is &#123;$name&#125;.The value of $name is Bob. string_format 字符串格式化（保留小数位） 123&#123;%$number%&#125; 23.5787446&#123;%$number|string_format:\"%.2f\"%&#125; 23.58&#123;%$number|string_format:\"%d\"%&#125; 24 default设置默认值 1&#123;%$user.name|default:'暂无'%&#125; replace 替换 1234$tags=\"设计，音乐\"&#123;$tags&#125; 设计，音乐&#123;$tags|replace:\"，\":\",\"&#125; 设计,音乐 section,sectionelse遍历数组中的数据 它的属性分别是：name表示循环的名称，loop决定循环次数的变量名称或者直接给定循环次数（loop=3），start表示循环执行的初始位置. 如果该值为负数，开始位置从数组的尾部算起，step决定循环的步长， 例如指定step=2将只遍历下标为0、2、4等的元素，max表示循环最大执行次数，show决定是否显示该循环。 12345&#123;section name=customer loop=$custid&#125;id: &#123;$custid[customer]&#125;&lt;br&gt;&#123;sectionelse&#125;there are no values in $custid.&#123;/section&#125;","tags":[{"name":"smarty","slug":"smarty","permalink":"http://yuyouyou.github.io/tags/smarty/"}]},{"title":"前端冷知识","date":"2016-02-18T02:44:36.000Z","path":"2016/02/18/front-cold/","text":"浏览器地址栏运行JavaScript代码 1javascript:alert('hello from address bar :)'); 浏览器地址栏运行HTML代码 1data:text/html,&lt;h1&gt;Hello, world!&lt;/h1&gt; 把浏览器当编辑器 12地址栏输入：data:text/html, &lt;html contenteditable&gt;控制台输入：document.body.contentEditable='true'; 实时编辑CSS 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;style style=\"display:block\" contentEditable&gt; body &#123; color: blue &#125; &lt;/style&gt; &lt;/body&gt;&lt;/html&gt; 生成随机字符串 12345function generateRandomAlphaNum(len) &#123; var rdmString = \"\"; for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len);&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://yuyouyou.github.io/tags/前端/"}]},{"title":"hexo常用命令","date":"2016-02-10T07:42:45.000Z","path":"2016/02/10/hexo/","text":"hexo npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate –deploy hexo deploy –generate 模版 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub 设置文章摘要以上是文章摘要 以下是余下全文","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yuyouyou.github.io/tags/hexo/"}]},{"title":"GitHub+Hexo搭建个人博客","date":"2015-09-23T02:47:40.000Z","path":"2015/09/23/github-hexo/","text":"准备工作 安装Git 安装Node.js PS：傻瓜式的安装即可。。。 申请GitHub 进入GitHub官网注册帐号 注册完成后，点击”New repository”，新建一个版本库 输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 启用GitHub Page 1、点击“Setting”菜单进入设置,点击”Launch automatic page generator”,如下所示： 2、点击底部的”Continue to layouts”3、点击”Publish page”,发布github默认生成的一个静态站点4、最后可以看到成功后的界面，还可以自己修改主题： 安装Hexo 在电脑上新建一个blog文件夹,该文件夹用于存放博客文件,然后右键单击选择“Git Bash”，执行以下命令： 使用淘宝NPM镜像 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 使用淘宝NPM安装Hexo 1$ cnpm install -g hexo-cli 1$ cnpm install hexo --save 检查安装成功否1$ hexo -v 本地运行hexo 初始化hexo 1$ hexo init 安装生成器 1$ cnpm install 运行hexo（以后要在本地运行博客只要输入该命令即可） 1$ hexo s -g 打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了 配置blog 打开blog/_config.yml文件，进行配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#博客名称title: 我的博客#副标题subtitle: 副标题#简介description: 简介#博客作者author: 作者#博客语言language: zh-CN#时区timezone:#博客地址,与申请的GitHub一致url: http://yuyouyou.github.io#博客链接格式permalink: :year/:month/:day/:title/permalink_defaults:source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:default_category: uncategorizedcategory_map:tag_map:#日期格式date_format: YYYY-MM-DDtime_format: HH:mm:ss#分页，每页文章数量per_page: 10pagination_dir: page#博客主题theme: landscape#发布设置deploy: type: git #elfwalk改为你的github用户名 repository: https://github.com/yuyouyou/yuyouyou.github.io.git branch: master 创建一篇文章并用编辑器编辑 1$ hexo new \"hello\" 发布博客 设置git身份信息 12$ git config --global user.name \"你的用户名\"$ git config --global user.email \"你的邮箱\" 安装hexo git插件 1$ cnpm install hexo-deployer-git --save 发布更新博客 1$ hexo d -g 发布成功后，访问yourname.github.io看下成果吧","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yuyouyou.github.io/tags/hexo/"}]}]