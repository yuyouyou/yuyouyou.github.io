[{"title":"降低网页加载时间","date":"2017-03-15T07:36:18.000Z","path":"2017/03/15/ninth-article/","text":"降低网页加载时间的方案太多了，在网上一查多的看不过来，所以我结合自身用到的以及网上的方案，来归纳一下吧，主要是一些前端能做的事情，以后get到新的方案，再不断添加吧。(╯▽╰)其实网页加载就是请求HTML，再顺带将它依赖的资源文件（比如：JS/CSS/iconfont）一并请求过来。从概念出发，我们就可以得出降低网页加载时间，最本质的方式就是：减少请求数量 与 减小请求大小。一、减少请求数量 优化图像1、将小图标合并成sprite图我们可以把多张背景图片和小图标合并雪碧图，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数。2、使用iconfont字体图标sprite图不适合无线端的响应式场景，所以越来越作为一个备用方案，而很多时候可以用iconfont字体来代替一些小图标。它就是用字体编码的形式来实现图标效果，既然是文字，那就可以随意设置颜色设置大小，相对来说比sprite方案更好，但是它只适用于纯色图标。3、base64:URL背景图片使用base64图可以减少HTTP请求，还可以避免跨域的问题。不了解的可以直接点击：详情传送门4、图片延迟加载图片延迟加载也称懒加载，常用于页面很长，图片很多的页面，整个页面少说几百K，多则上兆，如果想一次性加载完成，不仅用户要哭了，服务器也得哭了。为了避免这种请况发生，目前主流的做法是页面初次加载时，只显示当前可视区域的图片，当用户滚动页面的时候，当图片进入可视区域时再加载，这样可以明显的提高页面加载速度，而更少的图片并发请求数，也可以大大的减轻服务器的压力。5、标明图片高度和宽度如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。 Ajax调用尽量采用GET方法实际使用XMLHttpRequest时，如果使用POST方法实现，会发生2次HTTP请求，而使用GET方法只会发生1次HTTP请求。如果改用GET方法，HTTP请求减少50%。 避免使用@importcss @import语法允许你加载其它的CSS文件。有时非常有帮助，但是它并不是和主文件一起下载的，只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作，因此css @import引起的css解析延迟会加长页面留白期。 所以，要尽量避免使用css @import而采用link标签的方式引入。 二、减小请求大小 JS/CSS/HTML压缩很多公司都采用了这个手段，就不介绍太多，主要的方式有：1、通过构建工具实现，比如webpack/gulp/fis/grunt等。2、后台预编译。3、利用第三方online平台，手动上传压缩。 图片压缩同上可以手动处理图片或者借助第三方平台，手动处理的话推荐一个网站 tinypng，或者用第三方平台，比如七牛云平台。 三、其他方案 利用浏览器缓存浏览器缓存是允许访客的浏览器缓存你网站页面副本的一个功能。这有助于访客再次访问时，直接从缓存中读取内容而不必重新加载。这节省了向服务器发送HTTP请求的时间。 网址后加斜杠当用户打开一个链接时，服务器会推测链接这个地址包含哪种文件或页面。如果在连接后加上斜线（ / ），服务器就知道这是一个目录页，这样做可以减少页面的加载时间。如www.baidu.com/目录，会判断这个“目录是什么文件类型，或者是目录。 添加文件过期或缓存头同一用户频繁访问的图片、Js脚本文件等可以在Apache或Nginx设置其缓冲 时间，例如设置24小时过期时间，这样用户在访问过该页面之后再次访问时，同一组图片或JS不会再重复下载，从而减少了HTTP请求，用户访问速度明显有 所提升，同时服务器负载也会下降。 减少DNS查询减少DNS查询是一个WEB开发人员可以用了页面加载时间快速有效的方法。DNS查询需要话费很长的时间来返回一个主机名的IP地址。而浏览器在查询结束前不会进行任何操作。对于不同的元素可以使用不同的主机名，如URL、图像、脚本文件、样式文件、FLASH元素等。具有多种网络元素的页面经常需要进行多个DNS查询，因而花费的时间更长。减少不同域名的数量将减少并行下载的数量，加速你的网站。 最小化重定向重定向增加了额外的HTTP请求，因此也增加了页面加载时间。然而有时重定向却是不可避免的，如链接网站的不同部分、保存多个域名、或者从不存在的页面跳转到新页面。重定向增加了延迟时间，因此要尽量避免使用它。检查是否有损坏的链接，并立即修复。 CSS和JS的文件位置把CSS文件在页面底部引入可以禁止逐步渲染，节省浏览器加载和重绘页面元素的资源。把JS文件放在页面底部可以避免代码执行前的等待时间，从而提升页面加载速度。但是在某些情况下，需要JS在页面的顶部加载（如某些第三方跟踪脚本）。 延迟加载ga统计ga统计代码不阻塞页面渲染，不阻塞后续请求，但会阻塞window.onload事件，页面的表现方式是进度条一直加载。所以我们延迟执行ga初始化代码，将其放到window.onload函数中去执行，可以防止ga脚本阻塞window.onload事件。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yuyouyou.github.io/tags/性能优化/"}]},{"title":"函数节流与防抖","date":"2017-03-13T02:04:25.000Z","path":"2017/03/13/eighth-article/","text":"函数节流我们网站经常会有这样的需求，就是滚动浏览器滚动条的时候，更新页面上的某些布局内容或者去调用后台的某接口查询内容。如果不对函数调用的频率加以限制的话，那么可能我们滚动一次滚动条就会产生N次的调用了。所以我们每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。为了更好的理解这个概念，我们先来完成一个小需求，就是浏览器滚动条在滚动过程中打印n值：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;函数节流与防抖&lt;/title&gt;&lt;/head&gt;&lt;body style=\"height:1000px\"&gt;&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; window.onscroll=funHandler;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 功能倒是实现了，但是看一下控制台可以发现频繁的在打印n值，如果我们的 funHandler() 方法是 ajax 向服务器发送请求，那还得了啊！ 下面我们利用函数节流的两种方案来完成这个需求：第一种是按照《JavaScript高级程序设计》中的函数节流方法，原理很简单，利用定时器，让函数执行延迟500毫秒，在500毫秒内如果有函数又被调用则删除上一次调用，这次调用500毫秒后执行，如此往复。这样我刚才的代码可以改为：1234567891011121314151617&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; function throttle(method,context)&#123; clearTimeout(method.tId); method.tId=setTimeout(function()&#123; method.call(context); &#125;,500); &#125; window.onscroll=function()&#123; throttle(funHandler,window); &#125;;&lt;/script&gt; 滚动一下试试，果真只执行了一次 第二种是网上的一种节流方案，调试一下试试，效果和刚才是一样的：123456789101112131415161718&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; function throttle(method,delay)&#123; var timer=null; return function()&#123; var context=this, args=arguments; clearTimeout(timer); timer=setTimeout(function()&#123; method.apply(context,args); &#125;,delay); &#125; &#125; window.onscroll=throttle(funHandler,500);&lt;/script&gt; 函数防抖再来一个类似的需求，就像百度首页输入自动提示一样的东西，我在text上绑定keyup事件，每次键盘弹起的时候自动提示，但是又不想提示那么频繁，于是我用了上面方法，但是悲剧了，只有停止输入等500毫秒才会提示，在输入过程中根本就没有提示。看了一下代码，可不是嘛，只要是用户会盲打，在500毫秒内按一下键盘，提示函数就会不断被延迟，这样只有停下来的时候才会提示，这就没意义了。这个时候就用到了函数防抖，函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。其实它是在函数节流的基础上间隔固定时间来执行一次。如下所示：12345678910111213141516171819202122232425262728&lt;script type=\"text/javascript\"&gt; n=0; function funHandler()&#123; console.log(++n); &#125; function throttle(method,delay,duration)&#123; var timer=null, begin=new Date();// 记录下开始执行函数的时间 return function()&#123; var context=this, args=arguments, current=new Date();// 记录下当前时间 // 函数节流里的思路 clearTimeout(timer); // 记录下的两个时间相减再与duration进行比较 if(current-begin&gt;=duration)&#123; method.apply(context,args); begin=current; &#125;else&#123; timer=setTimeout(function()&#123; method.apply(context,args); &#125;,delay); &#125; &#125;&#125; window.onscroll=throttle(funHandler,500,2000);//因为返回函数句柄，不用包装函数了&lt;/script&gt; 这样每次我们判断间隔了多久，要是超过设置时间则立即执行一次，以刚才例子试一试效果，发现果真既没有频繁执行也没有就最后执行，感兴趣的朋友们可以试试哟！","tags":[{"name":"js","slug":"js","permalink":"http://yuyouyou.github.io/tags/js/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yuyouyou.github.io/tags/性能优化/"}]},{"title":"charles使用教程","date":"2017-03-02T09:20:04.000Z","path":"2017/03/02/seventh-article/","text":"记得我大三的时候有一门课叫计算机网络,是我最喜欢的王勇老师上的,当时勇哥给我们介绍了抓包工具,也是我第一次接触这玩意儿,当时用的wireshark,除了这个工具的名字貌似我什么都不记得了(&gt;_&lt;|||)。当时觉得这个工具应该和我以后的工作没多大联系吧,没想到出来做前端后,经常要用到抓包工具,特别是用来进行前端调试,觉得太赞了,我们可以用本地的文件来替换线上的文件,从而修复一些bug,还可以模拟不同的网络环境,或者设置网络请求。。。推荐一下我常用的两款抓包工具吧,一是fiddler,再就是我接下来介绍的charles。Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。工具就介绍这么多了,接下来介绍一下主要功能吧。 将 Charles 设置成系统代理选择菜单中的 “Proxy” -&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。如下所示： 需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。 用 Map 功能来修改服务器返回内容Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。在 Charles 的菜单中，选择 “Tools”-&gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。下面我来举一个 “Map Local” 的栗子: 第一步:选择需要抓包的请求,并且保存文件到本地,如下图所示,我们来抓取 http://yuyouyou.github.io/ 下面的main.js文件: 第二步:设置“Map Local”,如下图所示: 第三步:打开刚才抓取的js文件,并且编辑一下再保存,如下图所示: 现在访问 http://yuyouyou.github.io/ 就可以看到修改后的js文件替换了线上的js文件,是不是很酷啊,这对于我们调试线上的文件非常有帮助。 过滤网络请求如果我们需要只监控向指定目录服务器上发送的请求。有以下几种方法： 方法一:在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yuyouyou.github.io/ , 那么只需要在 Filter 栏中填入 yuyouyou 即可。 方法二：在 Charles 的菜单栏选择 “Proxy”-&gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图所示： 方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图所示： 给服务器做压力测试我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力。我们在需要打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。 截取 iPhone 上的网络封包 Charles 上的设置 要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。 iPhone 上的设置首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址。然后,在 iPhone 的 “ 设置 “-&gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888。设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单，点击 “Allow” 即可完成设置。接下来就可以愉快的抓取手机的请求了(^∀^)。 模拟慢速网络在 Charles 的菜单上，选择 “Proxy”-&gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图所示：","tags":[{"name":"抓包","slug":"抓包","permalink":"http://yuyouyou.github.io/tags/抓包/"},{"name":"网络","slug":"网络","permalink":"http://yuyouyou.github.io/tags/网络/"}]},{"title":"浏览器的重绘与重排","date":"2016-06-08T08:39:04.000Z","path":"2016/06/08/sixth-article/","text":"在前端开发中，性能优化是非常重要的一个环节，而谈到性能优化，我们就不得不了解一下浏览器的重绘与重排概念。 通常在 文档初次加载时，浏览器引擎会解析HTML文档来构建DOM树，之后根据DOM元素的几何属性构建一棵用于渲染的树。渲染树的每个节点都有大小和边距等属 性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了，再 根据渲染树节点的样式属性绘制出页面。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次 计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。 重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。 重排是更明显的一种改变，可以理解为渲染树需要重新计算。下面是常见的触发重排的操作： DOM元素的几何属性变化 当DOM元素的几何属性变化时，渲染树中的相关节点就会失效，浏览器会根据DOM元素的变化重新构建渲染树中失效的节点。之后，会根据新的渲染 树重新绘制这部分页面。而且，当前元素的重排也许会带来相关元素的重排。例如，容器节点的渲染树改变时，会触发子节点的重新计算，也会触发其后续兄弟节点 的重排，祖先节点需要重新计算子节点的尺寸也会产生重排。最后，每个元素都将发生重绘。可见，重排一定会引起浏览器的重绘，一个元素的重排通常会带来一系 列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。 DOM树的结构变化 当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器引擎布局的过程，类似于树的前序遍历，是一个从上到下从左到右的过程。 通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。所以，如果在body最前面插入一个元素，会导致整个文档的重新渲染，而在其后插入一个元 素，则不会影响到前面的元素。 获取某些属性 浏览器引擎可能会针对重排做了优化。比如Opera，它会等到有足够数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这 样就只发生一次重排。但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包 括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。 开发中，比较好的实践是尽量减少重排次数和缩小重排的影响范围。例如： 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。 需要多次重排的元素，position值最好为absolute或者fix，让它脱离文档流，这样就不会影响其他元素。所以有动画效果的元素最好设置绝对定位。 将多次改变样式属性的操作合并为一次操作，也就是将需要改变的的样式写在css中，并给一个类名，在js中只需要改变className即可。 由于display为none的元素不再渲染树中，对隐藏元素的操作不会引发其他元素的重排。如果要对一个元素进行复杂操作，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。 需要增加多个节点，可以一次性构建一个html片段，然后一次性添加到文档中去，而不是循环添加每一行。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yuyouyou.github.io/tags/性能优化/"}]},{"title":"windows下MongoDB的安装及配置","date":"2016-04-05T05:49:50.000Z","path":"2016/04/05/fifth-article/","text":"1、进入mongodb官网进行软件包下载。 2、选择windows平台，如图所示： 3、将zip文件解压放到盘符的根目录（如C：或D：），为了方便建议文件夹命名尽量简短如（d:\\mongodb）。 4、创建数据库文件的存放位置，比如d:/mongodb/data/db。启动mongodb服务之前必须创建数据库文件的存放文件夹，否则命令不会自动创建，而且不能启动成功。 5、打开cmd命令行，进入D:\\mongodb\\bin目录，输入如下的命令启动mongodb服务：1D:/mongodb/bin&gt;mongod --dbpath D:\\mongodb\\data\\db 6、mongodb默认连接端口27017，如果出现如图的情况，可以打开localhost:27017查看，发现如图则表示连接成功，如果不成功，可以查看端口是否被占用。 7、其实可以将MongoDB设置成Windows服务，这样每次开机MongoDB就自动启动了。 如图在d:\\mongodb\\data下新建文件夹log（存放日志文件）并且新建文件mongodb.log，在d:\\mongodb新建文件mongo.config。 8、用记事本打开mongo.config输入：12dbpath=D:\\mongodb\\data\\dblogpath=D:\\mongodb\\data\\log\\mongo.log 9、用管理员身份打开cmd命令行，进入D:\\mongodb\\bin目录，输入如下的命令：1D:\\mongodb\\bin&gt;mongod --config D:\\mongodb\\mongo.config 如果不成功可以改为如下：1mongod --config D:\\mongodb\\mongo.config --install --serviceName \"MongoDB\" 进入日志文件，查看日志发现已经成功了。如果失败有可能没有使用管理员身份，遭到拒绝访问。 10、打开cmd输入services.msc查看服务可以看到MongoDB服务，点击可以启动。如下所示：","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yuyouyou.github.io/tags/MongoDB/"}]},{"title":"smarty笔记(待续...)","date":"2016-03-23T10:19:51.000Z","path":"2016/03/23/fourth-article/","text":"日期格式 12345678910111213141516171819&#123;%$time|date_format:'%Y-%m-%d'%&#125; 格式为2016-08-03&#123;%$time|date_format:'%H:%M:%S'%&#125; 格式为14:33:00常见的：%Y 年, 数字, 4 位%y 年, 数字, 2 位%m 月份, 数字(01……12)%c 月份, 数字(1……12)%b 缩写的月份名字(Jan……Dec)%d 月份中的天数, 数字(00……31)%e 月份中的天数, 数字(0……31)%H 小时(00……23)%k 小时(0……23)%I 小时(01……12)%l 小时(1……12)%M 分钟(00……59)%S 秒(00……59)%w 星期名字(Sunday……Saturday)%a 缩写的星期名字(Sun……Sat) 取循环中的特殊地方 12345678910such as:&#123;%foreach $item.tags as $tag name=tags%&#125; &#123;%if $smarty.foreach.tags.last%&#125;,&#123;%/if%&#125;&#123;%/foreach%&#125;index表示当前数组索引，从0开始计算iteration表示当前循环次数，从1开始计算first表示第一个last表示最后一个total表示循环总次数 strip去除多余空格 123456$articleTitle=‘Grandmother of\\neight makes\\t hole in one.’&#123;%$articleTitle%&#125; Grandmother of eight makes hole in one.&#123;%$articleTitle|strip%&#125; Grandmother of eight makes hole in one.&#123;%$articleTitle|strip:\"&amp;nbsp;\"%&#125; Grandmother&amp;nbsp;of&amp;nbsp;eight&amp;nbsp;makes&amp;nbsp;hole&amp;nbsp;in&amp;nbsp;one. strip_tags去除html标签 1234$articleTitle=‘Blind Woman Gets &lt;font face=\\\"helvetica\\\"&gt;New Kidney&lt;/font&gt; from Dad she Hasn't Seen in &lt;b&gt;years&lt;/b&gt;.’&#123;%$articleTitle%&#125; Blind Woman Gets &lt;font face=\"helvetica\"&gt;New Kidney&lt;/font&gt; from Dad she Hasn't Seen in &lt;b&gt;years&lt;/b&gt;.&#123;%$articleTitle|strip_tags%&#125; Blind Woman Gets New Kidney from Dad she Hasn't Seen in years. assign 为模板变量赋值 1234&#123;%assign var=\"name\" value=\"Bob\"%&#125;The value of $name is &#123;$name&#125;.The value of $name is Bob. string_format 字符串格式化（保留小数位） 123&#123;%$number%&#125; 23.5787446&#123;%$number|string_format:\"%.2f\"%&#125; 23.58&#123;%$number|string_format:\"%d\"%&#125; 24 default设置默认值 1&#123;%$user.name|default:'暂无'%&#125; replace 替换 1234$tags=\"设计，音乐\"&#123;$tags&#125; 设计，音乐&#123;$tags|replace:\"，\":\",\"&#125; 设计,音乐 section,sectionelse遍历数组中的数据 它的属性分别是：name表示循环的名称，loop决定循环次数的变量名称或者直接给定循环次数（loop=3），start表示循环执行的初始位置. 如果该值为负数，开始位置从数组的尾部算起，step决定循环的步长， 例如指定step=2将只遍历下标为0、2、4等的元素，max表示循环最大执行次数，show决定是否显示该循环。 12345&#123;section name=customer loop=$custid&#125;id: &#123;$custid[customer]&#125;&lt;br&gt;&#123;sectionelse&#125;there are no values in $custid.&#123;/section&#125;","tags":[{"name":"smarty","slug":"smarty","permalink":"http://yuyouyou.github.io/tags/smarty/"}]},{"title":"前端冷知识(持续更新...)","date":"2016-02-18T02:44:36.000Z","path":"2016/02/18/third-article/","text":"浏览器地址栏运行JavaScript代码 1javascript:alert('hello from address bar :)'); 浏览器地址栏运行HTML代码 1data:text/html,&lt;h1&gt;Hello, world!&lt;/h1&gt; 把浏览器当编辑器 12地址栏输入：data:text/html, &lt;html contenteditable&gt;控制台输入：document.body.contentEditable='true'; 实时编辑CSS 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;style style=\"display:block\" contentEditable&gt; body &#123; color: blue &#125; &lt;/style&gt; &lt;/body&gt;&lt;/html&gt; 生成随机字符串 12345function generateRandomAlphaNum(len) &#123; var rdmString = \"\"; for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len);&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://yuyouyou.github.io/tags/前端/"}]},{"title":"hexo常用命令","date":"2016-02-10T07:42:45.000Z","path":"2016/02/10/second-article/","text":"hexo npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate –deploy hexo deploy –generate 模版 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub 设置文章摘要以上是文章摘要 以下是余下全文","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yuyouyou.github.io/tags/hexo/"}]},{"title":"GitHub+Hexo搭建个人博客","date":"2015-09-23T02:47:40.000Z","path":"2015/09/23/first-article/","text":"准备工作 安装Git 安装Node.js PS：傻瓜式的安装即可。。。 申请GitHub 进入GitHub官网注册帐号 注册完成后，点击”New repository”，新建一个版本库 输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 启用GitHub Page 1、点击“Setting”菜单进入设置,点击”Launch automatic page generator”,如下所示： 2、点击底部的”Continue to layouts”3、点击”Publish page”,发布github默认生成的一个静态站点4、最后可以看到成功后的界面，还可以自己修改主题： 安装Hexo 在电脑上新建一个blog文件夹,该文件夹用于存放博客文件,然后右键单击选择“Git Bash”，执行以下命令： 使用淘宝NPM镜像 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 使用淘宝NPM安装Hexo 1$ cnpm install -g hexo-cli 1$ cnpm install hexo --save 检查安装成功否1$ hexo -v 本地运行hexo 初始化hexo 1$ hexo init 安装生成器 1$ cnpm install 运行hexo（以后要在本地运行博客只要输入该命令即可） 1$ hexo s -g 打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了 配置blog 打开blog/_config.yml文件，进行配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#博客名称title: 我的博客#副标题subtitle: 副标题#简介description: 简介#博客作者author: 作者#博客语言language: zh-CN#时区timezone:#博客地址,与申请的GitHub一致url: http://yuyouyou.github.io#博客链接格式permalink: :year/:month/:day/:title/permalink_defaults:source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:default_category: uncategorizedcategory_map:tag_map:#日期格式date_format: YYYY-MM-DDtime_format: HH:mm:ss#分页，每页文章数量per_page: 10pagination_dir: page#博客主题theme: landscape#发布设置deploy: type: git #elfwalk改为你的github用户名 repository: https://github.com/yuyouyou/yuyouyou.github.io.git branch: master 创建一篇文章并用编辑器编辑 1$ hexo new \"hello\" 发布博客 设置git身份信息 12$ git config --global user.name \"你的用户名\"$ git config --global user.email \"你的邮箱\" 安装hexo git插件 1$ cnpm install hexo-deployer-git --save 发布更新博客 1$ hexo d -g 发布成功后，访问yourname.github.io看下成果吧","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yuyouyou.github.io/tags/hexo/"}]}]